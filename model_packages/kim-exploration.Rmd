---
title: "playing with time series"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      error = TRUE)

library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
# library(patchwork)
library(mgcv)
library(zyp)
library(EnvStats)
source(here::here("QAQC_flags", "functions.R"))
load(here::here("model_packages", "apaqc.RData"))
```

```{r}
# define list of summary stats functions
# for use in summarize across
summ_stats <- list(
  min = ~min(.x, na.rm = TRUE),
  median = ~median(.x, na.rm = TRUE),
  mean = ~mean(.x, na.rm = TRUE),
  max = ~max(.x, na.rm = TRUE)
)
```


```{r}
wq_monthly <- wq %>% 
  group_by(Year, Month) %>% 
  summarize(across(c(temp, spcond, sal, dopct, domgl),
                   summ_stats)) %>% 
  mutate(YearMonth = lubridate::ymd(paste(Year, Month, 1, sep = "-")))
```

```{r}
ggplot(wq_monthly, aes(x = YearMonth, y = temp_median,
                       col = as.factor(Year))) +
  geom_line(linewidth = 1) +
  theme_bw() +
  labs(title = "APACPWQ median temp",
       col = "Year",
       x = "Month/Year",
       y = "median temp (deg C)")

```


Subset to only go through 2019 because of a missing value in early 2020, and right now I don't want to deal with those.  

```{r}
wq_monthly_comp <- wq_monthly %>% 
  filter(Year <= 2019)
```


# simple models  

  

## simple linear regression  

Not accounting for autocorrelation or seasonality.

```{r}
lm1 <- lm(temp_median ~ YearMonth, data = wq_monthly_comp)
summary(lm1)
anova(lm1)


lm1_coeffs <- data.frame(mod = "lm1: ols",
                        slope = coef(lm1)["YearMonth"],
                        slope_se = coef(summary(lm1))["YearMonth", "Std. Error"],
                        phi = NA_real_,
                        row.names = NULL)
```

clear autocorrelation in those residuals.  

```{r}
acf(residuals(lm1))
```


add autocorrelation structure  

### arima  

```{r}
lm2 <- arima(wq_monthly_comp$temp_median, order = c(1, 0, 0),
             xreg = wq_monthly_comp$YearMonth)
lm2_coeffs <- data.frame(mod = "lm2: ar1",
                         slope = coef(lm2)["wq_monthly_comp$YearMonth"],
                         slope_se = sqrt(lm2$var.coef["wq_monthly_comp$YearMonth", "wq_monthly_comp$YearMonth"]),
                         phi = coef(lm2)["ar1"],
                        row.names = NULL)
```

### nlme::gls  

fails because of missing values (need to impute, I guess?)  

Missing value is row 218, so I'll only go through row 217

```{r}
# gls(temp_median ~ YearMonth, data = wq_monthly,
#     correlation = corAR1())
```

```{r}
lm3 <- gls(temp_median ~ YearMonth, data = wq_monthly_comp,
    correlation = corAR1())
lm3_phi <- coef(lm3$modelStruct$corStruct, unconstrained = FALSE)
# thanks to this https://stat.ethz.ch/pipermail/r-help/2006-July/109178.html
# for help pulling out phi

lm3_coeffs <- data.frame(mod = "lm3: gls with ar1",
                         slope = coef(lm3)["YearMonth"],
                         slope_se = coef(summary(lm3))["YearMonth", "Std.Error"],
                         phi = coef(lm3$modelStruct$corStruct, unconstrained = FALSE),
                        row.names = NULL)


lm3b <- gls(temp_median ~ YearMonth, data = wq_monthly_comp,
    correlation = corAR1(form = ~ YearMonth))
coef(lm3b$modelStruct$corStruct, unconstrained = FALSE)
acf(residuals(lm3b))[1]
```

**Linear Regression-type models**  

slope is probably "per day" because I have YearMonth in a date format, and that's just how R handles regressions. so I've multiplied it by 365.25 (to account for leap years) to get an estimate of change per year. I did not do this with the se; that matches the slope_perDay estimate.  

NOTE the models shown below were run on monthly data that had NOT been deseasonalized! The first row is regular linear regression; the following rows incorporate an AR1 structure but not any seasonality.  

```{r}
lms <- bind_rows(lm1_coeffs, lm2_coeffs, lm3_coeffs) %>% 
  rename(slope_perDay = slope) %>% 
  mutate(slope_perYear = slope_perDay * 365.25) %>% 
  relocate(slope_perYear, .before = slope_perDay)

lms %>% 
  knitr::kable(digits = c(7, 4, 7, 6, 4))
```



## mann-kendall/thiel-sen  

not deaseasonalized or anything.

looks like slope is coming out pretty similarly to the linear models where I haven't deseasonalized. not sure how se compares because it's not straightforward to pull out, at least not from envstats.

```{r}
ken1 <- kendallTrendTest(wq_monthly_comp$temp_median,
                         wq_monthly_comp$YearMonth)
ken1$estimate
ken1$estimate["slope"]
ken1$interval$limits
```



# manually de-seasonalize  

...by subtracting the median for each month (across all years)




# mgcv  

de-seasonalize by including a smooth term in the model.  

start without dealing with autocorrelation.

```{r}
gam1 <- gam(temp_median ~   
              YearMonth +  
              s(Month, bs='cc',k=12), #k = 12 to account for monthly variability, could make k=4 for seasons
            data=wq_monthly_comp, method="REML")  

gam1_coeffs <- data.frame(mod = "gam: s(Month)",
                          slope = gam1$coefficients["YearMonth"],
                          slope_se = summary(gam1)$se["YearMonth"],
                          phi = NA_real_,
                          row.names = NULL)

```


```{r}
# in theory, running gam without any smooth terms should look like a linear model.
gam0 <- gam(temp_median ~   
              YearMonth,
            data=wq_monthly_comp, method="REML")  

gam0_coeffs <- data.frame(mod = "gam: no smooths",
                          slope = gam0$coefficients["YearMonth"],
                          slope_se = summary(gam0)$se["YearMonth"],
                          phi = NA_real_,
                          row.names = NULL)

# se for the slope is smaller, but slope is the same.
```


```{r}
plot(gam1$fitted.values, type="l", col="darkblue", ylim=c(0.0,55), lwd=4,  #
     ylab="Temp", cex.axis=1.25, cex.lab=1.25,las=1, bty="L")
points(gam1$y, col="black", pch="o", cex=1.25)
lines(gam1$fitted.values, type="l", col="darkblue", lwd=4)
```


## gam with AR1  

```{r}
gam2 <- gamm(temp_median ~   
               YearMonth +  
               s(Month, bs='cc',k=12), #k = 12 to account for monthly variability, could make k=4 for seasons
             correlation = corAR1(),
             data=wq_monthly_comp, method="REML")  

# form = ~ YearMonth
# Gavin Simpson put that inside corAR1 when answering a question on stack overflow
# doesn't seem to affect model coefficients but does change the phi that it shows (using it gives 0; not using it gives 0.84ish for the linear models above and 0.17ish here)
# coefficients are a tiny bit different; not huge
# 2b has somewhat lower se for slope (5e-5 vs 5.9e-5)
# from the help for corAR1: form "Defaults to ~ 1, which corresponds to using the order of the observations in the data as a covariate, and no groups."
# maybe the difference would be if observations are skipped or anything?

gam2b <- gamm(temp_median ~   
               YearMonth +  
               s(Month, bs='cc',k=12), #k = 12 to account for monthly variability, could make k=4 for seasons
             correlation = corAR1(form = ~ YearMonth),
             data=wq_monthly_comp, method="REML") 

acf(gam2$gam$residuals)
acf(gam2b$gam$residuals)
acf(gam2$gam$residuals)[1] # this is really phi
acf(gam2b$gam$residuals)[1]  # this is really phi
# looks a little different but not much
# seems like it dealt with the autocorrelation somehow

gam2_coeffs <- data.frame(mod = "gam: s(Month) + AR1",
                          slope = gam2$lme$coefficients$fixed["XYearMonth"],
                          slope_se = sqrt(gam2$lme$varFix["XYearMonth", "XYearMonth"]),
                          phi = NA_real_,
                          row.names = NULL)
```


# zyp  

```{r}
zyp1 <- zyp.zhang(y = wq_monthly_comp$temp_median)
# trend per year (above is "per unit time", which is per month)
zyp1["trend"] * 12

zyp1["autocor"]  # this looks a lot like phi and/or acf(residuals(lm1 etc))
```

