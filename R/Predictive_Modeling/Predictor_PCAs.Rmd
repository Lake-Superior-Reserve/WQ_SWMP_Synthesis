---
title: "Predictor PCAs"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      error = TRUE)
```

```{r}
library(tidyverse)
library(corrplot)
library(vegan)
library(car)  # for vif()
```

## Read and wrangle data

```{r}
# wq, met, nut trends; overall medians; overall seasonal amplitudes
# station is 5-letter version
preds_all <- read.csv(here::here("Data", "compiled_predictors.csv"))

# all original trend calculations; will need to trim this
# only keep chla and do trends
# chla trend should already be present in preds_all though
# station is 7-8 letter version
responses <- read.csv(here::here("Outputs", "calculated_trends",
                                 "long-term-trends.csv"))

# trends in seasonal amplitudes
# station is 7-8 letter version
seas_trends <- readRDS(here::here("Outputs", "calculated_trends", 
                               "seasonal_amplitude_trends.rds"))

# SWMP CLUE classification matrix
# station is 7-8 letter version and all caps
swmp_clue <- readxl::read_xlsx(here::here("Data",
                                          "Copy of SWMP CLUE_All Site Classification_Mar2022_for review.xlsx"),
                               skip = 1)
```

```{r}
responses_main <- responses |> 
  filter(parameter %in% c("do_mgl_median",
                          "do_proportion_below2",
                          "chla_n"),
         station %in% seas_trends$station) |> 
  mutate(station = substr(station, 1, 5)) |> 
  select(station, parameter, Slope) |> 
  pivot_wider(names_from = parameter,
              values_from = Slope) |> 
  rename(chla_trend = chla_n,
         domgl_trend = do_mgl_median,
         do_below2_trend = do_proportion_below2)

seas_trends_main <- seas_trends |> 
  select(station, param, estimate) |> 
  mutate(station = substr(station, 1, 5),
         param = case_match(param,
                            "chla" ~ "chla_seasAmp_trend",
                            "do_mgl" ~ "domgl_seasAmp_trend",
                            "temp" ~ "temp_seasAmp_trend")) |> 
  pivot_wider(names_from = param, 
              values_from = estimate)

preds_main <- preds_all |> 
  select(-maxwspd_median, 
         -atemp_median, -atemp_trend,
         -reserve, -met_station,
         -chla_trend) |> 
  mutate(across(c(chla_n_median,
                  nh4f_median,
                  no23f_median,
                  po4f_median,
                  turb_median),
                function(x) log10(x+0.001))) |> 
  rename(turb_median.log10 = turb_median,
         chla_median.log10 = chla_n_median,
         nh4_median.log10 = nh4f_median,
         no23_median.log10 = no23f_median,
         po4_median.log10 = po4f_median,
         chla_seasAmp = chla_seas_ampl,
         domgl_seasAmp = do_mgl_seas_ampl,
         temp_seasAmp = temp_seas_ampl)

preds_main <- preds_main |> 
  select(order(names(preds_main))) |> 
  relocate(station)

# only pulling out numeric ones
swmp_clue_main <- swmp_clue |> 
  mutate(station = substr(tolower(StationCode), 1, 5)) |> 
  mutate(pctDev.log10 = log10(Dev_pctLand + 0.001)) |> 
  select(station, pctDev.log10) |> 
  filter(station %in% preds_main$station) |>
  distinct()
```

From pairs plots, log-Developed and log-Impervious are almost a straight line, so we should probably only use one. Ag percent land is hard to get bell-shaped. So only using log10-developed land for now.  

## Compile the master data frame  

Create one master data frame with all responses and predictors; center and scale all the predictors (NOT the responses); then subset from it for later modeling.  

Chla trend is in there twice - once as the response, and once with "_asPredictor" appended to the name for centering and scaling.  

```{r}
master_df <- left_join(responses_main, preds_main, by = "station") |> 
  left_join(seas_trends_main, by = "station") |> 
  left_join(swmp_clue_main, by = "station") |> 
  mutate(chla_trend_asPredictor = chla_trend) |> 
  relocate(chla_trend_asPredictor, .after = chla_trend) |> 
  column_to_rownames("station")

master_df_scaled <- master_df |> 
  mutate(across(c(4:ncol(master_df)),
                function(x) as.vector(scale(x))))
```

## Investigate the data frames  

### Unscaled  

```{r}
skimr::skim(master_df)
```

### Centered and scaled predictors  

```{r}
skimr::skim(master_df_scaled)
```


## Fill in NAs with 0  

```{r}
master_df_scaled[][is.na(master_df_scaled[])] <- 0
```


## Correlation matrix

```{r}
my_corrplot <- function(df){
  tmp <- df
  Q <- cor(tmp[4:ncol(tmp)], 
           method = "spearman",
           use = "pairwise.complete.obs")
  testRes = cor.mtest(tmp[4:ncol(tmp)], conf.level = 0.95)
  corrplot(Q, 
           type = "upper",
           order = 'FPC',
           method = "ellipse",
           p.mat = testRes$p, 
           sig.level = 0.05,
           insig = "label_sig",
           pch.cex = 2.5,
           pch.col = "gray20",
           tl.pos = "lt",
           tl.cex = 0.8,
           tl.srt = 45)
  corrplot(Q, add = TRUE,
           type = "lower",
           order = 'FPC',
           method = "number",
           insig = "n",
           diag = FALSE,
           tl.pos = "n",
           cl.pos = "n",
           number.cex = 0.6)
}

```


```{r}
my_corrplot(master_df_scaled)
```


`chla_trend_asPredictor` doesn't seem to have much correlation with any others, so since it's only going to be used with DO and not in PCAs for chl, I'll remove it from the matrices moving forward.  

## Chl trend predictive df  

```{r}
chl_df <- master_df_scaled |> 
  select(-domgl_trend,
         -do_below2_trend,
         -chla_trend_asPredictor)
```

## VIFs in predictive chl  

### function  

```{r}
vif_graph <- function(lm_obj){
  
  modvif <- as.data.frame(vif({{lm_obj}})) |> 
    rownames_to_column("predictor") |> 
    set_names(c("predictor", "VIF")) |> 
    arrange(VIF) |> 
    mutate(predictor = fct_inorder(predictor))
  
  
  ggplot(modvif) +
    geom_col(aes(x = VIF, y = predictor),
             fill = "cadetblue3") +
    geom_vline(xintercept = 5, linetype = "dashed", 
               col = "red3",
               linewidth = 1,
               alpha = 0.8) +
    geom_text(aes(x = VIF, y = predictor,
                  label = round(VIF, 1)),
              hjust = 1.1,
              col = "black",
              size = rel(3)) +
    labs(title = "VIFs for chla_trend ~ all predictors below")
}

```


### first use

```{r}
mod1 <- lm(chla_trend ~ ., data = chl_df)
vif_graph(mod1)
```


# Predictor-PCA Attempt 1    

## PCA1 - Latitudinal factors  

Back to that correlation matrix, lots of variables seem to be correlated with latitude:  

-  temp seasonal amplitude  
-  no23 median (?) - may not include this, not sure it makes sense with latitude  
-  chla seasonal amplitude  
-  spcond trend (?) - again, may not include, not sure it makes theoretical sense  
-  temp median  
-  daily PAR median  


So we'll peel those off into a PCA and see where that leaves us with our VIFs.  
```{r}
lat_df <- chl_df |> 
  select(latitude,
         temp_median,
         temp_seasAmp,
         dailyPAR_median,
         chla_seasAmp)

chl_df2 <- chl_df |> 
  select(-(names(lat_df)))

lat_pca <- rda(lat_df)
```

### Explore the PCA  

```{r}
screeplot(lat_pca, type = "lines")
biplot(lat_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

There were only 5 variables going into this PCA; first one or two are great. I like the separation along that second axis even though it's only explaining about 16% of the variance.    

```{r}
eigs <- summary(eigenvals(lat_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)
```

```{r}
# loadings
scores_lat <- as.data.frame(scores(lat_pca, choices = 1:2,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_lat,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_lat <- as.data.frame(scores(lat_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("Lat-PC1", "Lat-PC2"))
```


## Next model iteration  

First incorporate the PC axes from the 'latitude' PCA, and run the diagostics.  


```{r}
# using merge rather than a dplyr join function
# because the tidyverse doesn't let you use rownames to join
chl_df3 <- merge(chl_df2, sites_lat, by = "row.names") |> 
  column_to_rownames("Row.names")
```


```{r}
my_corrplot(chl_df3)
mod2 <- lm(chla_trend ~ ., data = chl_df3)
vif_graph(mod2)
```

That improved the VIFs a LOT!  

The next grouping of things that seem to be correlated together are the nitrogen medians, turbidity median, and DO amplitude - site condition sort of stuff:  

-  turb median  
-  spcond median  
-  nh4 median
-  no23 median  
-  DO seasonal amplitude  

PO4 median and precip look pretty related. Also to PO4 trend. Maybe that's for the *next* grouping. PO4 and NH4 trends are also pretty highly correlated.  Maybe those couple of groupings will do it for us.  

## PCA2 - Site conditions 1  

```{r}
sites1_df <- chl_df3 |> 
  select(turb_median.log10,
         spcond_median,
         nh4_median.log10,
         no23_median.log10,
         domgl_seasAmp)

chl_df4 <- chl_df3 |> 
  select(-(names(sites1_df)))

sites1_pca <- rda(sites1_df)
```

### Explore the PCA  

```{r}
screeplot(sites1_pca, type = "lines")
biplot(sites1_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

Looks like 2 axes are good here as well, again out of 5. Could go with 3 here, because the 3rd one explains about the same amount of variance as the 2nd, and it's where NO23 and DO separate some.     

```{r}
eigs <- summary(eigenvals(sites1_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)
```

```{r}
# loadings
scores_sites1 <- as.data.frame(scores(sites1_pca, choices = 1:3,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_sites1,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_sites1 <- as.data.frame(scores(sites1_pca, choices = 1:3,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("NDOturb-PC1", "NDOturb-PC2", "NDOturb-PC3"))
```


## Mod3 - Next model iteration  

Have generated two predictor PCAs already. Now consider a 3rd.   


```{r}
# using merge rather than a dplyr join function
# because the tidyverse doesn't let you use rownames to join
chl_df5 <- merge(chl_df4, sites_sites1, by = "row.names") |> 
  column_to_rownames("Row.names")
```


```{r}
my_corrplot(chl_df5)
mod3 <- lm(chla_trend ~ ., data = chl_df5)
vif_graph(mod3)
```

May not even need a 3rd, based solely on VIF; except that there are some tight correlations that I kind of want to deal with. (Most correlations are below 0.5 now, which seems promising, even if they are significant).  The total precip, PO4 median, PO4 trend, and NH4 trend.  Interestingly, PC2 from the previous PCA ('NDOturb') is negatively correlated with median PO4.   


## PCA3 - NPprecip  

```{r}
NPP_df <- chl_df5 |> 
  select(po4_median.log10,
         po4f_trend,
         nh4f_trend,
         totprcp_total)

chl_df6 <- chl_df5 |> 
  select(-(names(NPP_df)))

NPP_pca <- rda(NPP_df)
```

### Explore the PCA  

```{r}
screeplot(NPP_pca, type = "lines")
biplot(NPP_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

Again need 2-3 of the 4. Based on eigenvalues, I'd say just 2, but I'll pull info for the 3rd anyway.        

```{r}
eigs <- summary(eigenvals(NPP_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)
```

```{r}
# loadings
scores_NPP <- as.data.frame(scores(NPP_pca, choices = 1:3,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_NPP,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_NPP <- as.data.frame(scores(NPP_pca, choices = 1:3,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("NPP-PC1", "NPP-PC2", "NPP-PC3"))
```


## Mod4 - Next model iteration  

Have generated 2 predictor PCAs already. Now consider that 3rd one and its affects on a predictive model.     


```{r}
# using merge rather than a dplyr join function
# because the tidyverse doesn't let you use rownames to join
chl_df7 <- merge(chl_df6, sites_NPP, by = "row.names") |> 
  column_to_rownames("Row.names")
```


```{r}
my_corrplot(chl_df7)
mod4 <- lm(chla_trend ~ ., data = chl_df7)
vif_graph(mod4)
```

Hm. Some correlations between my PCs. Might need to throw all the nitrogen, phosphorus, and precip into the same PCA???  

Also, temp trend and temp seasonality trend are correlated (negatively).  

Precip trend seems to be positively correlated with the N/DO/Turbidity PC2, and negatively with the N/P/Precip PC2.   

Yep, NDOturb-PC2 and NPP-PC2 are negatively correlated.  


# Predictor PCA Attempt 2  

Maybe go for the latitudinal PCA first again, and then see if we can get all the nutrient parameters (and precip) into the same PCA in a good way.  

SO, can start with `lat_pca` and `chl_df3`, which has the first 2 PCs from the latitude grouping PCA incorporated.  

Let's remind ourselves of the starting point:  

```{r}
my_corrplot(chl_df3)
vif_graph(mod2)
```


## PCA2b - Nutrient conditions and change  

All the factors from the last two PCAs above:  

```{r}
big_pc_df <- chl_df3 |> 
  select(turb_median.log10,
         spcond_median,
         nh4_median.log10,
         no23_median.log10,
         domgl_seasAmp,
         po4_median.log10,
         po4f_trend,
         nh4f_trend,
         totprcp_total)

chl_df4b <- chl_df3 |> 
  select(-(names(big_pc_df)))

big_pca <- rda(big_pc_df)
```

### Explore the PCA  

```{r}
screeplot(big_pca, type = "lines")
biplot(big_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

Looks like we need several axes from this one, maybe 4-5? The advantage here is that the axes are orthogonal from one another.       

```{r}
eigs <- summary(eigenvals(big_pca))
knitr::kable(eigs[, 1:8],
             caption = "Variance explained by PC axes",
             digits = 4)
```

```{r}
# loadings
scores_bigpca <- as.data.frame(scores(big_pca, choices = 1:5,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_bigpca,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_bigpca <- as.data.frame(scores(big_pca, choices = 1:4,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("water-PC1", "water-PC2", "water-PC3", "water-PC4"))
```


## Mod3 - Next model iteration  

Have generated two predictor PCAs already. Now consider a 3rd.   


```{r}
# using merge rather than a dplyr join function
# because the tidyverse doesn't let you use rownames to join
chl_df5b <- merge(chl_df4b, sites_bigpca, by = "row.names") |> 
  column_to_rownames("Row.names")
```


```{r}
my_corrplot(chl_df5b)
mod3b <- lm(chla_trend ~ ., data = chl_df5b)
vif_graph(mod3b)
```

temp trend and temp seasonality trend are negatively correlated. temp trend isn sightly negatively correlated with Lat-PC2; maybe should add that into the latitudinal one.spcond trend and precip trend are negatively correlated. Lat PC1 is positively correlated with spcond trend and water PC4.  


Maybe should include spcond trend and precip trend in the latitudinal PCA. Maybe also temp trend and temp seasonality trend?  

VIFs are still not bad.  Seeing come correlations between the different PCAs though.  


# Predictor PCA Attempt 3  

Adding those variables to the latitudinal PCA. Does it still make sense to call this latitudinal? Unsure. Then use the 'water' PCA as well. See if these separate PCAs make sense, and work; if not, maybe time to just try full-on principal components regression.  



```{r}
lat_df2 <- chl_df |> 
  select(latitude,
         temp_median,
         temp_seasAmp,
         temp_trend,
         temp_seasAmp_trend,
         dailyPAR_median,
         precp_trend,
         spcond_trend,
         chla_seasAmp)

chl_df2c <- chl_df |> 
  select(-(names(lat_df2)))

lat_pca2 <- rda(lat_df2)
```


```{r}
screeplot(lat_pca2, type = "lines")
biplot(lat_pca2,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

```{r}
eigs <- summary(eigenvals(lat_pca2))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)
```

Need 4-5 axes here.  

```{r}
# loadings
scores_lat2 <- as.data.frame(scores(lat_pca2, choices = 1:5,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_lat2,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_lat2 <- as.data.frame(scores(lat_pca2, choices = 1:5,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("Lat-PC1", "Lat-PC2", "Lat-PC3", "Lat-PC4", "Lat-PC5"))
```

Chla seasonality doesn't load in a big way until PC4.... hm, wonder if it's needed here.  

## Next model iteration  

First incorporate the PC axes from the 'latitude' PCA, and run the diagostics.  


```{r}
# using merge rather than a dplyr join function
# because the tidyverse doesn't let you use rownames to join
chl_df3c <- merge(chl_df2c, sites_lat2, by = "row.names") |> 
  column_to_rownames("Row.names")
```

```{r}
my_corrplot(chl_df3c)
mod2c <- lm(chla_trend ~ ., data = chl_df3c)
vif_graph(mod2c)
```


## PCA2c - Nutrient conditions and change  

All the factors from the last two PCAs above:  

```{r}
big_pc_dfc <- chl_df3c |> 
  select(turb_median.log10,
         spcond_median,
         nh4_median.log10,
         no23_median.log10,
         domgl_seasAmp,
         po4_median.log10,
         po4f_trend,
         nh4f_trend,
         totprcp_total)

chl_df4c <- chl_df3c |> 
  select(-(names(big_pc_dfc)))

big_pcac <- rda(big_pc_dfc)
```

### Explore the PCA  

```{r}
screeplot(big_pcac, type = "lines")
biplot(big_pcac,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

I really like that biplot.         

```{r}
eigs <- summary(eigenvals(big_pcac))
knitr::kable(eigs[, 1:8],
             caption = "Variance explained by PC axes",
             digits = 4)
```

Again, probably want 4-5.

```{r}
# loadings
scores_bigpcac <- as.data.frame(scores(big_pcac, choices = 1:5,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_bigpcac,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_bigpcac <- as.data.frame(scores(big_pcac, choices = 1:5,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("water-PC1", "water-PC2", "water-PC3", "water-PC4", "water-PC5"))
```


## Next model iteration  


```{r}
chl_df5c <- merge(chl_df4c, sites_bigpcac, by = "row.names") |> 
  column_to_rownames("Row.names")
```


```{r}
my_corrplot(chl_df5c)
mod3c <- lm(chla_trend ~ ., data = chl_df5c)
vif_graph(mod3c)
```

That corrplot looks pretty good, actually. The correlated PCs are the higher ones in the lat and water PCs, which I wasn't sure we'd want to include anyway - so we can drop some of those.  

Now it's down to whether these are interpretable.  

***  
***  
***  

# List of responses and predictors:

-   Responses: chla trend, domgl trend, do\<2 trend.

-   Predictors (pulled from slide 6 of \'[SWMP Synthesis model pieces](https://docs.google.com/presentation/d/1DGCyR5U5pYlU9qp5I0hYXLhKjZjly_Kq1iUfF721s-0/edit?usp=sharing)\', which we discussed some during a February Data Team meeting): 

    -   DO responses only: 

        -   Chla slope

    -   All responses; do PCAs to reduce variable load. Red highlights mean a parameter hasn\'t been calculated.

        -   Related to responses:

            -   Chla median

            -   Chla median seasonal amplitude

            -   Chla trend in seasonal amplitude

            -   DO mgl median seasonal amplitude

            -   DO mgl trend in seasonal amplitude

        -   WQ params:

            -   SpCond slope

            -   SpCond median

            -   Temp slope

            -   Temp median

            -   Temp median seasonal amplitude

            -   Temp trend in seasonal amplitude

            -   Turbidity slope

            -   Turbidity median

        -   MET params:

            -   Precip slope - note this was calculated on sqrt-transformed values.

            -   Precip median yearly total - there is a column in the compiled predictors file named \'totprcp_total\' - ranges in value from 4 (TJR) up to \~120 (GND); believe this is mm so we\'re looking at median monthly totals. Median of all months still useful though? 

            -   PAR slope

            -   PAR median

            -   Wind speed median

        -   NUT params. Note: slopes were calculated on log10-transformed values. Medians were calculated using censored data methods and need to be log10-transformed before inclusion.

            -   PO4 slope

            -   PO4 median

            -   NH4 slope

            -   NH4 median

            -   NO23 slope

            -   NO23 median
