---
title: "Predictor PCAs"
output: 
  html_document:
    toc: true
    toc_float: true
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      error = TRUE)
```

```{r}
library(tidyverse)
library(corrplot)
library(vegan)
library(car)  # for vif()
```

## Read and wrangle data

```{r}
# wq, met, nut trends; overall medians; overall seasonal amplitudes
# station is 5-letter version
preds_all <- read.csv(here::here("Data", "compiled_predictors.csv"))

# all original trend calculations; will need to trim this
# only keep chla and do trends
# chla trend should already be present in preds_all though
# station is 7-8 letter version
responses <- read.csv(here::here("Outputs", "calculated_trends",
                                 "long-term-trends.csv"))

# trends in seasonal amplitudes
# station is 7-8 letter version
seas_trends <- readRDS(here::here("Outputs", "calculated_trends", 
                               "seasonal_amplitude_trends.rds"))

# SWMP CLUE classification matrix
# station is 7-8 letter version and all caps
swmp_clue <- readxl::read_xlsx(here::here("Data",
                                          "Copy of SWMP CLUE_All Site Classification_Mar2022_for review.xlsx"),
                               skip = 1)
```

```{r}
responses_main <- responses |> 
  filter(parameter %in% c("do_mgl_median",
                          "do_proportion_below2",
                          "chla_n"),
         station %in% seas_trends$station) |> 
  mutate(station = substr(station, 1, 5)) |> 
  select(station, parameter, Slope) |> 
  pivot_wider(names_from = parameter,
              values_from = Slope) |> 
  rename(chla_trend = chla_n,
         domgl_trend = do_mgl_median,
         do_below2_trend = do_proportion_below2)

seas_trends_main <- seas_trends |> 
  select(station, param, estimate) |> 
  mutate(station = substr(station, 1, 5),
         param = case_match(param,
                            "chla" ~ "chla_seasAmp_trend",
                            "do_mgl" ~ "domgl_seasAmp_trend",
                            "temp" ~ "temp_seasAmp_trend")) |> 
  pivot_wider(names_from = param, 
              values_from = estimate)

preds_main <- preds_all |> 
  select(-maxwspd_median, 
         -atemp_median, -atemp_trend,
         -reserve, -met_station,
         -chla_trend) |> 
  mutate(across(c(chla_n_median,
                  nh4f_median,
                  no23f_median,
                  po4f_median,
                  turb_median),
                function(x) log10(x+0.001))) |> 
  rename(turb_median.log10 = turb_median,
         chla_median.log10 = chla_n_median,
         nh4_median.log10 = nh4f_median,
         no23_median.log10 = no23f_median,
         po4_median.log10 = po4f_median,
         chla_seasAmp = chla_seas_ampl,
         domgl_seasAmp = do_mgl_seas_ampl,
         temp_seasAmp = temp_seas_ampl)

preds_main <- preds_main |> 
  select(order(names(preds_main))) |> 
  relocate(station)

# only pulling out numeric ones
swmp_clue_main <- swmp_clue |> 
  mutate(station = substr(tolower(StationCode), 1, 5)) |> 
  mutate(pctDev.log10 = log10(Dev_pctLand + 0.001)) |> 
  select(station, pctDev.log10) |> 
  filter(station %in% preds_main$station) |>
  distinct()
```

From pairs plots, log-Developed and log-Impervious are almost a straight line, so we should probably only use one. Ag percent land is hard to get bell-shaped. So only using log10-developed land for now.  

## Compile the master data frame  

Create one master data frame with all responses and predictors; center and scale all the predictors (NOT the responses); then subset from it for later modeling.  

Chla trend is in there twice - once as the response, and once with "_asPredictor" appended to the name for centering and scaling.  

```{r}
master_df <- left_join(responses_main, preds_main, by = "station") |> 
  left_join(seas_trends_main, by = "station") |> 
  left_join(swmp_clue_main, by = "station") |> 
  mutate(chla_trend_asPredictor = chla_trend) |> 
  relocate(chla_trend_asPredictor, .after = chla_trend) |> 
  column_to_rownames("station")

master_df_scaled <- master_df |> 
  mutate(across(c(4:ncol(master_df)),
                function(x) as.vector(scale(x))))
```

## Investigate the data frames  

### Unscaled  

```{r}
skimr::skim(master_df)
```

### Centered and scaled predictors  

```{r}
skimr::skim(master_df_scaled)
```


## Fill in NAs with 0  

```{r}
master_df_scaled[][is.na(master_df_scaled[])] <- 0
```


## Correlation matrix

```{r}
my_corrplot <- function(df, start_col){
  tmp <- df
  Q <- cor(tmp[start_col:ncol(tmp)], 
           method = "spearman",
           use = "pairwise.complete.obs")
  testRes = cor.mtest(tmp[start_col:ncol(tmp)], conf.level = 0.95)
  corrplot(Q, 
           type = "upper",
           order = 'FPC',
           method = "ellipse",
           p.mat = testRes$p, 
           sig.level = 0.05,
           insig = "label_sig",
           pch.cex = 2.5,
           pch.col = "gray20",
           tl.pos = "lt",
           tl.cex = 0.8,
           tl.srt = 45)
  corrplot(Q, add = TRUE,
           type = "lower",
           order = 'FPC',
           method = "number",
           insig = "n",
           diag = FALSE,
           tl.pos = "n",
           cl.pos = "n",
           number.cex = 0.6)
}

```


```{r}
my_corrplot(master_df_scaled, start_col = 4)
```


`chla_trend_asPredictor` doesn't seem to have much correlation with any others, so since it's only going to be used with DO and not in PCAs for chl, I'll remove it from the matrices moving forward.  

## Chl trend predictive df  

```{r}
chl_df <- master_df_scaled |> 
  select(-domgl_trend,
         -do_below2_trend,
         -chla_trend_asPredictor)
```

## VIFs in predictive chl  

### function  

```{r}
vif_graph <- function(lm_obj){
  
  modvif <- as.data.frame(vif({{lm_obj}})) |> 
    rownames_to_column("predictor") |> 
    set_names(c("predictor", "VIF")) |> 
    arrange(VIF) |> 
    mutate(predictor = fct_inorder(predictor))
  
  
  ggplot(modvif) +
    geom_col(aes(x = VIF, y = predictor),
             fill = "cadetblue3") +
    geom_vline(xintercept = 5, linetype = "dashed", 
               col = "red3",
               linewidth = 1,
               alpha = 0.8) +
    geom_text(aes(x = VIF, y = predictor,
                  label = round(VIF, 1)),
              hjust = 1.1,
              col = "black",
              size = rel(3)) +
    labs(title = "VIFs for chla_trend ~ all predictors below")
}

```


### first use

```{r}
mod1 <- lm(chla_trend ~ ., data = chl_df)
vif_graph(mod1)
```


# PCA Predictor Combinations  

Several variations of PCAs were attempted in the file `Predictor_PCAs-building-up-to-main.Rmd` - this was the best combination I could get PCA-wise. Now to actually make some "weed-out" choices, make sure the PCs don't correlate with each other (or other predictors that are left), and see if they do make sense.  

In this iteration, I will use the screeplots and "first axis that gets the variance explained over 80%" to guide the choice of how many axes to use.  

May want to use the `PCAtest` package if folks want to make choices based on significance instead (uses bootstrapped permutations).  https://github.com/arleyc/PCAtest  

paper:  https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8858582/



**Things that should be together**  

-  latitude, temp_median, temp_seasAmp, dailyPAR_median  
-  spcond_trend and prcp_trend  
-  temp_trend, temp_seasAmp_trend, and [chl_seasAmp - later moved to latitudinal PCA]  
-  turb_median, spcond_median, nh4_median, no23_median, po4_median, totprcp; domgl_seasAmp; po4_trend, nh4_trend. po4_median through totprcp load strongly on axis 2; turb_median through domgl_seasAmp load strongly on axis 1. If we want to split, could split this way. But again, first 4-5 axes seem to do well at explaining the variability in these 9 variables.  

### Latitude PCA  

```{r}
lat_df <- chl_df |> 
  select(latitude,
         temp_median,
         temp_seasAmp,
         dailyPAR_median,
         chla_seasAmp)

chl_df2 <- chl_df |> 
  select(-(names(lat_df)))

lat_pca <- rda(lat_df)
```


```{r}
screeplot(lat_pca, type = "lines")
biplot(lat_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```


```{r}
eigs <- summary(eigenvals(lat_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)
```

Use first 2 axes. Showing information for 4, for reference.  


```{r}
# loadings
scores_lat <- as.data.frame(scores(lat_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_lat,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_lat <- as.data.frame(scores(lat_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("Lat-PC1", "Lat-PC2"))
```




### spcond, prcp, temp trends PCA  

-  spcond_trend and prcp_trend  
-  temp_trend, temp_seasAmp_trend, [moved up to Lat-PCA  and chl_seasAmp]    
  

```{r}
SPT_df <- chl_df |> 
  select(spcond_trend,
         precp_trend,
         temp_trend,
         temp_seasAmp_trend)

chl_df3 <- chl_df2 |> 
  select(-(names(SPT_df)))

SPT_pca <- rda(SPT_df)
```


```{r}
screeplot(SPT_pca, type = "lines")
biplot(SPT_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

```{r}
eigs <- summary(eigenvals(SPT_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)
```

Want 2-3 of these. Start with 3 unless it gives us problems.    


```{r}
# loadings
scores_SPT <- as.data.frame(scores(SPT_pca, choices = 1:3,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_SPT,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_SPT <- as.data.frame(scores(SPT_pca, choices = 1:3,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("SPT-PC1", "SPT-PC2", "SPT-PC3"))
```



### nutrients, water and prcp medians PCA  

-  turb_median, spcond_median, nh4_median, no23_median, po4_median, totprcp; domgl_seasAmp; po4_trend, nh4_trend. po4_median through totprcp load strongly on axis 2; turb_median through domgl_seasAmp load strongly on axis 1. If we want to split, could split this way. But again, first 4-5 axes seem to do well at explaining the variability in these 9 variables.  


```{r}
water_medians_df <- chl_df |> 
  select(turb_median.log10,
         spcond_median,
         nh4_median.log10,
         no23_median.log10,
         po4_median.log10,
         totprcp_total,
         domgl_seasAmp,
         po4f_trend,
         nh4f_trend)

chl_df4 <- chl_df3 |> 
  select(-(names(water_medians_df)))

water_medians_pca <- rda(water_medians_df)
```


```{r}
screeplot(water_medians_pca, type = "lines")
biplot(water_medians_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

       

```{r}
eigs <- summary(eigenvals(water_medians_pca))
knitr::kable(eigs[, 1:5],
             caption = "Variance explained by PC axes",
             digits = 4)
```

Want 4 of these. Showing information for 5.    

```{r}
# loadings
scores_water <- as.data.frame(scores(water_medians_pca, choices = 1:5,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_water,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_water <- as.data.frame(scores(water_medians_pca, choices = 1:4,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("water-PC1", "water-PC2", "water-PC3", "water-PC4"))
```


# Combine into new big data frame  

```{r}
combined_df <- bind_cols(chl_df4,
                         sites_lat,
                         sites_SPT,
                         sites_water)
```

We've got 18 variables now instead of the original 27, but hopefully much less correlation. Let's find out.  

```{r}
my_corrplot(combined_df, start_col = 2)
```

The only one I'm really worried about is chl median being correlated with water-PC1.  

Check VIFs.  

```{r}
mod2 <- lm(chla_trend ~ ., data = combined_df)
vif_graph(mod2)
```

Might need to incorporate chl median into that water PC..... unless we have theoretical reasons why we want it to be estimated on its own (I can certainly make that argument). Otherwise I'm generally okay with what I'm seeing, especially after all of the other attempts.  

## Meaning of these PC axes  

What do all of these PC axes actually mean though? How can we interpret them?  

-  **Lat-PC1** - increasing latitude, seasonal amplitude of temperature, seasonal amplitude of chla; decreasing median temp and daily PAR.   
-  **Lat-PC2**  - increasing seasonal amplitude of chla (biggest loading); decreasing seasonal amplitude of temperature. Other loadings small.  
-  **SPT-PC1** - (SPT = salinity, precip, temp) - bigger temperature increases; decreasing trend in temperature seasonal amplitude; increasing spcond trend.    
-  **SPT-PC2** - increasing precip trend; decreasing/smaller spcond trend; a little bit of smaller trend in temperature seasonal amplitude  
-  **SPT-PC3** - smaller spcond and precip trends; increasing temp trend.  
-  **water-PC1**  - increasing median spcond; decreasing median turbidity, median NO23, DO mg/L seasonal amplitude, NH4 median.  
-  **water-PC2** - increasing median PO4, trend in NH4, trend in PO4; decreasing median precipitation.  
-  **water-PC3** - increasing PO4 trend, NH4 trend, median precip; decreasing median NH4 and less so, decreasing NO23 and PO4 medians.  
-  **water-PC4** - increasing median NO23; decreasing DOmg/L seasonal amplitude, median spcond, median NH4.   

***  
***  



# List of responses and predictors:

-   Responses: chla trend, domgl trend, do\<2 trend.

-   Predictors (pulled from slide 6 of \'[SWMP Synthesis model pieces](https://docs.google.com/presentation/d/1DGCyR5U5pYlU9qp5I0hYXLhKjZjly_Kq1iUfF721s-0/edit?usp=sharing)\', which we discussed some during a February Data Team meeting): 

    -   DO responses only: 

        -   Chla slope

    -   All responses; do PCAs to reduce variable load. Red highlights mean a parameter hasn\'t been calculated.

        -   Related to responses:

            -   Chla median

            -   Chla median seasonal amplitude

            -   Chla trend in seasonal amplitude

            -   DO mgl median seasonal amplitude

            -   DO mgl trend in seasonal amplitude

        -   WQ params:

            -   SpCond slope

            -   SpCond median

            -   Temp slope

            -   Temp median

            -   Temp median seasonal amplitude

            -   Temp trend in seasonal amplitude

            -   Turbidity slope

            -   Turbidity median

        -   MET params:

            -   Precip slope - note this was calculated on sqrt-transformed values.

            -   Precip median yearly total - there is a column in the compiled predictors file named \'totprcp_total\' - ranges in value from 4 (TJR) up to \~120 (GND); believe this is mm so we\'re looking at median monthly totals. Median of all months still useful though? 

            -   PAR slope

            -   PAR median

            -   Wind speed median

        -   NUT params. Note: slopes were calculated on log10-transformed values. Medians were calculated using censored data methods and need to be log10-transformed before inclusion.

            -   PO4 slope

            -   PO4 median

            -   NH4 slope

            -   NH4 median

            -   NO23 slope

            -   NO23 median
