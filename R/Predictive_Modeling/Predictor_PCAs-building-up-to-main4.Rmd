---
title: "Still more"
date: "`r Sys.Date()`"
output: html_document
---

In the first batch of PCAs, I hadn't included median chlorophyll (???), so making sure to do that here.  


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      error = TRUE)
```

```{r}
library(tidyverse)
library(corrplot)
library(vegan)
library(car)  # for vif()
library(Hmisc)
library(GGally)
library(broom)
library(lme4)
library(lmerTest) # for ddf option in anova
library(performance) # for check_model()
```

# Data Import {.tabset}  

## Read and wrangle

```{r}
# wq, met, nut trends; overall medians; overall seasonal amplitudes
# station is 5-letter version
preds_all <- read.csv(here::here("Data", "compiled_predictors.csv"))

# all original trend calculations; will need to trim this
# only keep chla and do trends
# chla trend should already be present in preds_all though
# station is 7-8 letter version
responses <- read.csv(here::here("Outputs", "calculated_trends",
                                 "long-term-trends.csv"))

# trends in seasonal amplitudes
# station is 7-8 letter version
seas_trends <- readRDS(here::here("Outputs", "calculated_trends", 
                               "seasonal_amplitude_trends.rds"))

# SWMP CLUE classification matrix
# station is 7-8 letter version and all caps
swmp_clue <- readxl::read_xlsx(here::here("Data",
                                          "Copy of SWMP CLUE_All Site Classification_Mar2022_for review.xlsx"),
                               skip = 1)
```

```{r}
responses_main <- responses |> 
  filter(parameter %in% c("do_mgl_median",
                          "do_proportion_below2",
                          "chla_n"),
         station %in% seas_trends$station) |> 
  mutate(station = substr(station, 1, 5)) |> 
  select(station, parameter, Slope) |> 
  pivot_wider(names_from = parameter,
              values_from = Slope) |> 
  rename(chla_trend = chla_n,
         domgl_trend = do_mgl_median,
         do_below2_trend = do_proportion_below2)

seas_trends_main <- seas_trends |> 
  select(station, param, estimate) |> 
  mutate(station = substr(station, 1, 5),
         param = case_match(param,
                            "chla" ~ "chla_seasAmp_trend",
                            "do_mgl" ~ "domgl_seasAmp_trend",
                            "temp" ~ "temp_seasAmp_trend")) |> 
  pivot_wider(names_from = param, 
              values_from = estimate)

preds_main <- preds_all |> 
  select(-maxwspd_median, 
         -atemp_median, -atemp_trend,
         -reserve, -met_station,
         -chla_trend) |> 
  mutate(across(c(chla_n_median,
                  nh4f_median,
                  no23f_median,
                  po4f_median,
                  turb_median),
                function(x) log10(x+0.001))) |> 
  rename(turb_median.log10 = turb_median,
         chla_median.log10 = chla_n_median,
         nh4_median.log10 = nh4f_median,
         no23_median.log10 = no23f_median,
         po4_median.log10 = po4f_median,
         chla_seasAmp = chla_seas_ampl,
         domgl_seasAmp = do_mgl_seas_ampl,
         temp_seasAmp = temp_seas_ampl)

preds_main <- preds_main |> 
  select(order(names(preds_main))) |> 
  relocate(station)

# only pulling out numeric ones
swmp_clue_main <- swmp_clue |> 
  mutate(station = substr(tolower(StationCode), 1, 5)) |> 
  mutate(pctDev.log10 = log10(Dev_pctLand + 0.001)) |> 
  select(station, pctDev.log10) |> 
  filter(station %in% preds_main$station) |>
  distinct()
```

## Compile  

Create one master data frame with all responses and predictors; center and scale all the predictors (NOT the responses); then subset from it for later modeling.

Chla trend is in there twice - once as the response, and once with "\_asPredictor" appended to the name for centering and scaling.

```{r}
master_df <- left_join(responses_main, preds_main, by = "station") |> 
  left_join(seas_trends_main, by = "station") |> 
  left_join(swmp_clue_main, by = "station") |> 
  mutate(chla_trend_asPredictor = chla_trend) |> 
  relocate(chla_trend_asPredictor, .after = chla_trend) |> 
  column_to_rownames("station")

master_df_scaled <- master_df |> 
  mutate(across(c(4:ncol(master_df)),
                function(x) as.vector(scale(x))))
```

Fill in NAs with 0

```{r}
master_df_scaled[][is.na(master_df_scaled[])] <- 0
```

## Predictive dfs for all responses

```{r}
chl_df <- master_df_scaled |> 
  select(-domgl_trend,
         -do_below2_trend,
         -chla_trend_asPredictor)

domgl_df <- master_df_scaled |> 
  select(-do_below2_trend,
         -chla_trend)

do_below2_df <- master_df_scaled |> 
  select(-domgl_trend,
         -chla_trend)
```

```{r}
preds_main_numeric <- select(preds_main, -station)
preds_main_numeric_scaled <- select(chl_df, -chla_trend)
```

From pairs plots, log-Developed and log-Impervious are almost a straight line, so we should probably only use one. Ag percent land is hard to get bell-shaped. So only using log10-developed land for now.



## Unscaled df overview  


```{r}
skimr::skim(master_df)
```

## Scaled df overview  

```{r}
skimr::skim(master_df_scaled)
```



## Correlation matrix

```{r}
my_corrplot <- function(df, start_col){
  tmp <- df
  Q <- cor(tmp[start_col:ncol(tmp)], 
           method = "spearman",
           use = "pairwise.complete.obs")
  testRes = cor.mtest(tmp[start_col:ncol(tmp)], conf.level = 0.95)
  corrplot(Q, 
           type = "upper",
           order = 'FPC',
           method = "ellipse",
           p.mat = testRes$p, 
           sig.level = 0.05,
           insig = "label_sig",
           pch.cex = 2,
           pch.col = "gray40",
           tl.pos = "lt",
           tl.cex = 0.8,
           tl.srt = 45)
  corrplot(Q, add = TRUE,
           type = "lower",
           order = 'FPC',
           method = "number",
           insig = "n",
           diag = FALSE,
           tl.pos = "n",
           cl.pos = "n",
           number.cex = 0.6)
}

```

# Corrplot of numeric predictors  

(chla trend not included in this data frame)  

```{r}
my_corrplot(preds_main_numeric_scaled, start_col = 1)
```


# VIFs 


```{r vif-function}
vif_graph <- function(lm_obj){
  
  modvif <- as.data.frame(vif({{lm_obj}})) |> 
    rownames_to_column("predictor") |> 
    set_names(c("predictor", "VIF")) |> 
    arrange(VIF) |> 
    mutate(predictor = fct_inorder(predictor))
  
  
  ggplot(modvif) +
    geom_col(aes(x = VIF, y = predictor),
             fill = "cadetblue3") +
    geom_vline(xintercept = 5, linetype = "dashed", 
               col = "red3",
               linewidth = 1,
               alpha = 0.8) +
    geom_text(aes(x = VIF, y = predictor,
                  label = round(VIF, 1)),
              hjust = 1.1,
              col = "black",
              size = rel(3)) +
    labs(title = "VIFs for chla_trend ~ all predictors below")
}

```

## All numeric predictors, using chl as response

```{r vif-first-use}
mod1 <- lm(chla_trend ~ ., data = chl_df)
vif_graph(mod1)
```

# Global model diagnostics {.tabset}  

## chla  

### regular lm  

```{r}
glance(mod1)

check_model(mod1)
```

### mixed model  

```{r}
chl_df2 <- chl_df |> 
  rownames_to_column("station") |> 
  mutate(reserve = substr(station, 1, 3)) |> 
  column_to_rownames("station")
vars <- paste(names(chl_df2)[2:(ncol(chl_df2) - 1)], collapse = " + ")
fo <- as.formula(paste("chla_trend ~ ", vars, "+ (1|reserve)"))
mod1b <- lmer(fo,
              data = chl_df2)
mod_anov <- anova(mod1b, ddf = "Kenward-Roger")
MuMIn::r.squaredGLMM(mod1b)

check_model(mod1b)
```


Marginal R^2 (R2m) represents the variance explained by the fixed effects. Conditional R^2 (R2c) represents the variance explained by the entire model, which includes both fixed and random effects.  




## do mgl  

### regular lm  

```{r}
mod1 <- lm(domgl_trend ~ .,
           data = domgl_df)
glance(mod1)
check_model(mod1)
```


### mixed model  

```{r}
domgl_df2 <- domgl_df |> 
  rownames_to_column("station") |> 
  mutate(reserve = substr(station, 1, 3)) |> 
  column_to_rownames("station")
vars <- paste(names(domgl_df2)[2:(ncol(domgl_df2) - 1)], collapse = " + ")
fo <- as.formula(paste("domgl_trend ~ ", vars, "+ (1|reserve)"))
mod1b <- lmer(fo,
              data = domgl_df2)
mod_anov <- anova(mod1b, ddf = "Kenward-Roger")
MuMIn::r.squaredGLMM(mod1b)

check_model(mod1b)
```



## do proportion < 2  

haven't written yet  


# Predictive modeling  {.tabset}  

## Latitude PCA full  

```{r}
lat_df <- chl_df |> 
  select(latitude,
         temp_median,
         temp_seasAmp,
         dailyPAR_median,
         chla_seasAmp)
lat_pca <- rda(lat_df)

screeplot(lat_pca, type = "lines")
biplot(lat_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(lat_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)

# loadings
scores_lat <- as.data.frame(scores(lat_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_lat,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_lat <- as.data.frame(scores(lat_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("LatPC1", "LatPC2"))

```

### updated corrplot  

```{r}
# using merge rather than a dplyr join function
# because the tidyverse doesn't let you use rownames to join
chl_df2 <- chl_df |> 
  select(-all_of(names(lat_df)))
chl_df3 <- merge(chl_df2, sites_lat, by = "row.names") |> 
  column_to_rownames("Row.names")
my_corrplot(chl_df3, start_col = 2)
```

### chl model  

```{r}
mod2 <- lm(chla_trend ~ ., data = chl_df3)
vif_graph(mod2)
glance(mod2)
check_model(mod2)
```

Very little change in R^2.  

```{r}
chl_df3b <- chl_df3 |> 
  rownames_to_column("station") |> 
  mutate(reserve = substr(station, 1, 3)) |> 
  column_to_rownames("station")
vars <- paste(names(chl_df3b)[2:(ncol(chl_df3b) - 1)], collapse = " + ")
fo <- as.formula(paste("chla_trend ~ ", vars, "+ (1|reserve)"))
mod1b <- lmer(fo,
              data = chl_df3b)
mod_anov <- anova(mod1b, ddf = "Kenward-Roger")
MuMIn::r.squaredGLMM(mod1b)

check_model(mod1b)
```


### domgl model  

```{r}
# using merge rather than a dplyr join function
# because the tidyverse doesn't let you use rownames to join
domgl_df2 <- domgl_df |> 
  select(-all_of(names(lat_df)))
domgl_df3 <- merge(domgl_df2, sites_lat, by = "row.names") |> 
  column_to_rownames("Row.names")
my_corrplot(domgl_df3, start_col = 2)
```

Only difference between this and the chla model's corrplot should be that we have `chla_trend_asPredictor` in here. It doesn't seem to correlate strongly with anything.  

```{r}
mod2 <- lm(domgl_trend ~ ., data = domgl_df3)
vif_graph(mod2)
glance(mod2)
```

Those R^2s didn't change at all!  


## Latitude PCA reduced  

removing chl seasonal amplitude.  

```{r}
lat_df2 <- chl_df |> 
  select(latitude,
         temp_median,
         temp_seasAmp,
         dailyPAR_median)
lat_pca2 <- rda(lat_df2)

screeplot(lat_pca2, type = "lines")
biplot(lat_pca2,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs2 <- summary(eigenvals(lat_pca2))
knitr::kable(eigs2[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)

# loadings
scores_lat2 <- as.data.frame(scores(lat_pca2, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_lat2,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_lat2 <- as.data.frame(scores(lat_pca2, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("LatPC1", "LatPC2"))

```

### updated corrplot  

```{r}
# using merge rather than a dplyr join function
# because the tidyverse doesn't let you use rownames to join
chl_df2b <- chl_df |> 
  select(-all_of(names(lat_df2)))
chl_df3b <- merge(chl_df2b, sites_lat2, by = "row.names") |> 
  column_to_rownames("Row.names")
my_corrplot(chl_df3b, start_col = 2)
```

### chl model  

```{r}
mod2b <- lm(chla_trend ~ ., data = chl_df3b)
vif_graph(mod2b)
glance(mod2b)
check_model(mod2b)
```

Very little change in R^2.  



### domgl model  

```{r}
# using merge rather than a dplyr join function
# because the tidyverse doesn't let you use rownames to join
domgl_df2 <- domgl_df |> 
  select(-all_of(names(lat_df2)))
domgl_df3 <- merge(domgl_df2, sites_lat, by = "row.names") |> 
  column_to_rownames("Row.names")
my_corrplot(domgl_df3, start_col = 2)
```

Only difference between this and the chla model's corrplot should be that we have `chla_trend_asPredictor` in here. It doesn't seem to correlate strongly with anything.  

```{r}
mod2 <- lm(domgl_trend ~ ., data = domgl_df3)
vif_graph(mod2)
glance(mod2)
```

Those R^2s didn't change at all!  