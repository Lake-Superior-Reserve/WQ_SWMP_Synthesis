---
title: "Predictor PCAs"
output: 
  html_document:
    toc: true
    toc_float: true
date: "`r Sys.Date()`"
---

This document is being started after conversation at the Data Analysis Team Meeting on 4/2/24. The group expressed interest in separating out medians from other wq variables, and possibly leaving them out of the predictors completely.  

Additionally, I've been spending some time reading Frank Harrell's book *Regression Modeling Strategies*, and he uses some clustering - the `Hmisc::varclust()` function - to help wtih data reduction. I'll look at that here as well to try to come up with some different groupings of predictor variables.  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      error = TRUE)
```

```{r}
library(tidyverse)
library(corrplot)
library(vegan)
library(car)  # for vif()
library(Hmisc)
library(GGally)
```

# Data Import {.tabset}  

## Read and wrangle

```{r}
# wq, met, nut trends; overall medians; overall seasonal amplitudes
# station is 5-letter version
preds_all <- read.csv(here::here("Data", "compiled_predictors.csv"))

# all original trend calculations; will need to trim this
# only keep chla and do trends
# chla trend should already be present in preds_all though
# station is 7-8 letter version
responses <- read.csv(here::here("Outputs", "calculated_trends",
                                 "long-term-trends.csv"))

# trends in seasonal amplitudes
# station is 7-8 letter version
seas_trends <- readRDS(here::here("Outputs", "calculated_trends", 
                               "seasonal_amplitude_trends.rds"))

# SWMP CLUE classification matrix
# station is 7-8 letter version and all caps
swmp_clue <- readxl::read_xlsx(here::here("Data",
                                          "Copy of SWMP CLUE_All Site Classification_Mar2022_for review.xlsx"),
                               skip = 1)
```

```{r}
responses_main <- responses |> 
  filter(parameter %in% c("do_mgl_median",
                          "do_proportion_below2",
                          "chla_n"),
         station %in% seas_trends$station) |> 
  mutate(station = substr(station, 1, 5)) |> 
  select(station, parameter, Slope) |> 
  pivot_wider(names_from = parameter,
              values_from = Slope) |> 
  rename(chla_trend = chla_n,
         domgl_trend = do_mgl_median,
         do_below2_trend = do_proportion_below2)

seas_trends_main <- seas_trends |> 
  select(station, param, estimate) |> 
  mutate(station = substr(station, 1, 5),
         param = case_match(param,
                            "chla" ~ "chla_seasAmp_trend",
                            "do_mgl" ~ "domgl_seasAmp_trend",
                            "temp" ~ "temp_seasAmp_trend")) |> 
  pivot_wider(names_from = param, 
              values_from = estimate)

preds_main <- preds_all |> 
  select(-maxwspd_median, 
         -atemp_median, -atemp_trend,
         -reserve, -met_station,
         -chla_trend) |> 
  mutate(across(c(chla_n_median,
                  nh4f_median,
                  no23f_median,
                  po4f_median,
                  turb_median),
                function(x) log10(x+0.001))) |> 
  rename(turb_median.log10 = turb_median,
         chla_median.log10 = chla_n_median,
         nh4_median.log10 = nh4f_median,
         no23_median.log10 = no23f_median,
         po4_median.log10 = po4f_median,
         chla_seasAmp = chla_seas_ampl,
         domgl_seasAmp = do_mgl_seas_ampl,
         temp_seasAmp = temp_seas_ampl)

preds_main <- preds_main |> 
  select(order(names(preds_main))) |> 
  relocate(station)

# only pulling out numeric ones
swmp_clue_main <- swmp_clue |> 
  mutate(station = substr(tolower(StationCode), 1, 5)) |> 
  mutate(pctDev.log10 = log10(Dev_pctLand + 0.001)) |> 
  select(station, pctDev.log10) |> 
  filter(station %in% preds_main$station) |>
  distinct()
```

From pairs plots, log-Developed and log-Impervious are almost a straight line, so we should probably only use one. Ag percent land is hard to get bell-shaped. So only using log10-developed land for now.

## Compile  

Create one master data frame with all responses and predictors; center and scale all the predictors (NOT the responses); then subset from it for later modeling.

Chla trend is in there twice - once as the response, and once with "\_asPredictor" appended to the name for centering and scaling.

```{r}
master_df <- left_join(responses_main, preds_main, by = "station") |> 
  left_join(seas_trends_main, by = "station") |> 
  left_join(swmp_clue_main, by = "station") |> 
  mutate(chla_trend_asPredictor = chla_trend) |> 
  relocate(chla_trend_asPredictor, .after = chla_trend) |> 
  column_to_rownames("station")

master_df_scaled <- master_df |> 
  mutate(across(c(4:ncol(master_df)),
                function(x) as.vector(scale(x))))
```

## Unscaled df overview  


```{r}
skimr::skim(master_df)
```

## Scaled df overview  

```{r}
skimr::skim(master_df_scaled)
```

Fill in NAs with 0

```{r}
master_df_scaled[][is.na(master_df_scaled[])] <- 0
```

## Correlation matrix

```{r}
my_corrplot <- function(df, start_col){
  tmp <- df
  Q <- cor(tmp[start_col:ncol(tmp)], 
           method = "spearman",
           use = "pairwise.complete.obs")
  testRes = cor.mtest(tmp[start_col:ncol(tmp)], conf.level = 0.95)
  corrplot(Q, 
           type = "upper",
           # order = 'FPC',
           method = "ellipse",
           p.mat = testRes$p, 
           sig.level = 0.05,
           insig = "label_sig",
           pch.cex = 2.5,
           pch.col = "gray20",
           tl.pos = "lt",
           tl.cex = 0.8,
           tl.srt = 45)
  corrplot(Q, add = TRUE,
           type = "lower",
           # order = 'FPC',
           method = "number",
           insig = "n",
           diag = FALSE,
           tl.pos = "n",
           cl.pos = "n",
           number.cex = 0.6)
}

```

```{r}
my_corrplot(master_df_scaled, start_col = 4)
```

`chla_trend_asPredictor` doesn't seem to have much correlation with any others, so since it's only going to be used with DO and not in PCAs for chl, I'll remove it from the matrices moving forward.

## Chl trend predictive df

```{r}
chl_df <- master_df_scaled |> 
  select(-domgl_trend,
         -do_below2_trend,
         -chla_trend_asPredictor)
```

## VIFs in predictive chl


```{r vif-function}
vif_graph <- function(lm_obj){
  
  modvif <- as.data.frame(vif({{lm_obj}})) |> 
    rownames_to_column("predictor") |> 
    set_names(c("predictor", "VIF")) |> 
    arrange(VIF) |> 
    mutate(predictor = fct_inorder(predictor))
  
  
  ggplot(modvif) +
    geom_col(aes(x = VIF, y = predictor),
             fill = "cadetblue3") +
    geom_vline(xintercept = 5, linetype = "dashed", 
               col = "red3",
               linewidth = 1,
               alpha = 0.8) +
    geom_text(aes(x = VIF, y = predictor,
                  label = round(VIF, 1)),
              hjust = 1.1,
              col = "black",
              size = rel(3)) +
    labs(title = "VIFs for chla_trend ~ all predictors below")
}

```

```{r vif-first-use}
mod1 <- lm(chla_trend ~ ., data = chl_df)
vif_graph(mod1)
```

# Clustering {.tabset}  

pp. 166-167 of Harrell 2001 - on his example dataset, he uses Spearman correlations; then in the cluster analysis, Hoeffding D statistics. "D will detect nonmotonic associations".  

## unscaled, Spearman  


```{r}
preds_main_numeric <- select(preds_main, -station)
vc1 <- varclus(as.matrix(preds_main_numeric),
               sim = "spearman")
plot(vc1, ylab = "Spearman clustering, raw predictors")
```

Groupings:  

-  Latitude group I used before falls out (in each of these clusters, honestly): latitude, median temp, PAR, temp seasonal amplitude, and chl seasonal amplitude.  
-  precip trend and spcond trend. PAR trend and no23 trend are the next closest cluster to these two, which I can only sort of fathom.    
-  no23 median, spcond median, chla median, turb median; do seasonal amplitude - most of these are describing salinity/turbidity/chl conditions  
-  po4 median, precip median, nh4 median, wind speed median - po4 and nh4 make sense to me together; precip and wind speed, maybe - all 4 of them together is a little strange, but.... maybe not. wetter and winder conditions lead to certain po4 and nh4 conditions?  
-  temp trend, turbidity trend; po4 trend, nh4 trend - these don't make as much sense to me together (aside from po4 and nh4 trends)  


These are sort of different median and trend groupings, though.  



## unscaled, Hoeffding  


```{r}
vc2 <- varclus(as.matrix(preds_main_numeric),
               sim = "hoeffding")
plot(vc2, ylab = "Hoeffding clustering, raw predictors")
```


Groupings:  

-  Latitude group again: latitude, median temp, PAR, temp seasonal amplitude, and chl seasonal amplitude.  
-  precip trend and PAR trend together here, with no23 trend, and po4 median and precip median. 
-  spcond trend, chl median, turb median, and do seasonal amplitude. Not sure why spcond trend groups with these others - I could see an argument for the other three. Chl and turb medians seem especially logical. The next closest group to this is the latitude grouping.
-  no23 median & spcond median; turb trend; nh4 median, wspd median - this one doesn't make a ton of sense to me either. Can sort of see no23, spcond, and nh4 medians. Not sure how turb trend or wspd fit in.  


## scaled, Spearman  



```{r}
preds_main_numeric_scaled <- select(chl_df, -chla_trend)
vc1 <- varclus(as.matrix(preds_main_numeric_scaled),
               sim = "spearman")
plot(vc1, ylab = "Spearman clustering, scaled predictors")
```

Groupings:  

-  latitude stuff  
-  no23 median, spcond median; chla median, turb median; do seasonal amplitude  
-  po4 median, precip median; nh4 median, wind speed median  
-  temp trend, temp seasonality trend; turb trend  
-  nh4 trend, po4 trend; PAR trend, do seasonal amplitude trend  
-  % developed; precip trend and spcond trend; no23 trend and chl seasonality trend  


## scaled, Hoeffding  


```{r}
vc2 <- varclus(as.matrix(preds_main_numeric_scaled),
               sim = "hoeffding")
plot(vc2, ylab = "Hoeffding clustering, scaled predictors")
```


Groupings:  

-  Latitude group  
-  po4 median + median precip; no23 trend, PAR trend, precip trend.  
-  no23 median, spcond median; do seasonality; chla and turb medians  
-  nh4 median, wspd median; turb trend  
-  nh4 trend, po4 trend; do seasonality trend - somewhat clustered with turb, nh4, wspd from prior line  
-  temp trend, temp seasonality trend, spcond trend, % developed  


## summary of clustering  

The latitude factors always came out together, and the same - so that's a good solid grouping of variables.  

NH4 and PO4 trends always group with each other. Their medians group in a more variable way.  

Chl and turb group together a lot, as medians and/or trends.  

NO23 median groups with various spcond params frequently - this surprised me some but I can see where it would make sense.  

The Spearman clustering on centered, scaled variables leads to some potential, meaningful structure I can play with. Medians do tend to separate from trends in that version, and that should address the work group's interest in separating them out. The trick will be to make sure I can do so without a lot of collinearity.  

Another thing Harrell's book made me think about is how many PCs to keep. We really want to maximize the variability explained by the first axis or two of a PCA. It would be great if we could only keep the first one or two, and then we don't have to worry about whether to keep PCs 1, 2, and 3 if PC4 is significant. We could just keep the PCs from a grouping, only 1 PC, or drop them all - in candidate models for model selection.  


# PCA groupings 1   

## Variables  

Variables in each grouping are:  

**Latitude** - 2 PCs for 84.7%    

-  latitude
-  temp_median  
-  dailyPAR_median  
-  temp_seasAmp  
-  chla_seasAmp  


**Medians a** - 2 PCs for 76% (3 PCs for 88.7%)   

-  no23_median.log10  
-  spcond_median  
-  chla_median.log10  
-  turb_median.log10  
-  domgl_seasAmp  
  

**Medians b** - 2 PCs for 81.2%   

-  po4_median.log10  
-  totprcp_total  (median monthly precip)  
-  nh4_median.log10  
-  wspd_median  


**Trends a** - 2 PCs for 83.7%    

-  turb_trend  
-  temp_trend  
-  temp_seasAmp_trend  


**Trends b** - 2 PCs for 73.3%  (3 PCs for 92.5%)    

-  nh4f_trend  
-  po4f_trend  
-  dailyPAR_trend  
-  domgl_seasAmp_trend  
  

**Trends c** - 3 PCs for 75% (4 for 88%)    

-  precp_trend  
-  spcond_trend  
-  pctDev.log10  
-  no23f_trend  
-  chla_seasAmp_trend  



## Latitude  

Vars: temp_median, latitude, dailyPAR_median, temp_seasAmp, chla_seasAmp  
```{r}
lat_df <- chl_df |> 
  select(latitude,
         temp_median,
         temp_seasAmp,
         dailyPAR_median,
         chla_seasAmp)
lat_pca <- rda(lat_df)
```

```{r}
screeplot(lat_pca, type = "lines")
biplot(lat_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

```{r}
eigs <- summary(eigenvals(lat_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)
```

Use first 2 axes. Showing information for 4, for reference.

```{r}
# loadings
scores_lat <- as.data.frame(scores(lat_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_lat,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_lat <- as.data.frame(scores(lat_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("Lat-PC1", "Lat-PC2"))
```


## Medians a  

Vars: no23_median.log10, spcond_median, chla_median.log10, turb_median.log10, domgl_seasAmp  

```{r}
mediansA_df <- chl_df |> 
  select(no23_median.log10,
         spcond_median,
         chla_median.log10,
         turb_median.log10,
         domgl_seasAmp)
mediansA_pca <- rda(mediansA_df)

screeplot(mediansA_pca, type = "lines")
biplot(mediansA_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(mediansA_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_mediansA <- as.data.frame(scores(mediansA_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_mediansA,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_mediansA <- as.data.frame(scores(mediansA_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("mediansA-PC1", "mediansA-PC2"))
```

Takes 3 PCs to get above 80% variance explained, but 2 PCs gets to 76% and that seems pretty good....  


## Medians b  

Vars: po4_median.log10, totprcp_total, nh4_median.log10, wspd_median  

```{r}
mediansB_df <- chl_df |> 
  select(po4_median.log10,
         totprcp_total,
         nh4_median.log10,
         wspd_median)
mediansB_pca <- rda(mediansB_df)

screeplot(mediansB_pca, type = "lines")
biplot(mediansB_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(mediansB_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_mediansB <- as.data.frame(scores(mediansB_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_mediansB,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_mediansB <- as.data.frame(scores(mediansB_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("mediansB-PC1", "mediansB-PC2"))
```

2 axes do a very good job here.  

## Trends a  

Vars: turb_trend, temp_trend, temp_seasAmp_trend  

```{r}
trendsA_df <- chl_df |> 
  select(turb_trend,
         temp_trend,
         temp_seasAmp_trend)
trendsA_pca <- rda(trendsA_df)

screeplot(trendsA_pca, type = "lines")
biplot(trendsA_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(trendsA_pca))
knitr::kable(eigs[, 1:3],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_trendsA <- as.data.frame(scores(trendsA_pca, choices = 1:3,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_trendsA,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_trendsA <- as.data.frame(scores(trendsA_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("trendsA-PC1", "trendsA-PC2"))
```

Again, 2 axes good here.  

## Trends b  

Vars: nh4f_trend, po4f_trend, dailyPAR_trend, domgl_seasAmp_trend  

```{r}
trendsB_df <- chl_df |> 
  select(nh4f_trend,
         po4f_trend,
         dailyPAR_trend,
         domgl_seasAmp_trend)
trendsB_pca <- rda(trendsB_df)

screeplot(trendsB_pca, type = "lines")
biplot(trendsB_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(trendsB_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_trendsB <- as.data.frame(scores(trendsB_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_trendsB,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_trendsB <- as.data.frame(scores(trendsB_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("trendsB-PC1", "trendsB-PC2"))
```

2 PCs doesn't get us quite to 80% but does do pretty well; around 76% again and seems worth getting rid of the third axis.  

## Trends c  

Vars: precp_trend, spcond_trend, pctDev.log10, no23f_trend, chla_seasAmp_trend  

```{r}
trendsC_df <- chl_df |> 
  select(precp_trend,
         spcond_trend,
         pctDev.log10,
         no23f_trend,
         chla_seasAmp_trend)
trendsC_pca <- rda(trendsC_df)

screeplot(trendsC_pca, type = "lines")
biplot(trendsC_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(trendsC_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_trendsC <- as.data.frame(scores(trendsC_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_trendsC,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_trendsC <- as.data.frame(scores(trendsC_pca, choices = 1:3,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("trendsC-PC1", "trendsC-PC2", "trendsC-PC3"))
```

Really need 3 axes from this one.  

## Outcome  

ALL of the variables went into a PCA above in this go-round.  

```{r}
preds_from_pca1 <- bind_cols(
  sites_lat,
  sites_mediansA,
  sites_mediansB,
  sites_trendsA,
  sites_trendsB,
  sites_trendsC
)

chl_df_pca1 <- chl_df |> 
  select(chla_trend) |> 
  bind_cols(preds_from_pca1)
```

```{r}
my_corrplot(chl_df_pca1, start_col = 2)
plot(varclus(as.matrix(preds_from_pca1)))
```

Latitude is correlating really strongly with PC2 of one of the median groups, but not PC1 - so I don't really know what to do about that. Some of the median groups are correlating with some of the trend groups, don't really know how to tackle that either.    

What do a few of these pairs plots look like.  

```{r}
sub_df <- chl_df_pca1 |> 
  select("Lat-PC1", "Lat-PC2", "mediansA-PC1", "mediansA-PC2", "mediansB-PC1", "trendsC-PC1")
my_corrplot(sub_df, 1)
ggpairs(sub_df)
```

Lat-PC1 and mediansA-PC2 is pretty concerning. trendsC-PC1 is concerning with both Lat-PC1 (even though corr wasn't significant) and mediansA-PC1. trendsC-1 with mediansA-2 isn't quite as linear as the others, even though the Spearman correlation was significant.    

PC2 of mediansA is largely no23 median opposed to chla, turb, spcond medians and do_mgl seasonal amplitude.  

Doesn't feel like throwing these two groups together into the same PCA is going to do anything good, but will try it below.  

```{r}
mod1 <- lm(chla_trend ~ ., data = chl_df_pca1)
vif_graph(mod1)
```

Pretty great actually.  

```{r}
lowerFn <- function(data, mapping, method = "lm", ...) {
  p <- ggplot(data = data, mapping = mapping) +
    geom_point(colour = "navy", alpha = 0.8) +
    geom_smooth(method = method, color = "darkorange", 
                se = FALSE, linewidth = 0.9, ...)
  p
}
```

```{r}
ggpairs(chl_df_pca1[, 2:ncol(chl_df_pca1)],
        upper = list(continuous = "cor", method = "spearman"),
        lower = list(continuous = wrap(lowerFn)),
        axisLabels = "none")
```


## follow-up  

### combining lat and mediansA  

```{r}
latMedA_df <- bind_cols(lat_df, mediansA_df)
latMedA_pca <- rda(latMedA_df)

screeplot(latMedA_pca, type = "lines")
biplot(latMedA_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(latMedA_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_latMedA <- as.data.frame(scores(latMedA_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_latMedA,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_latMedA <- as.data.frame(scores(latMedA_pca, choices = 1:3,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("latMedA-PC1", "latMedA-PC2", "latMedA-PC3"))
```

The biplot is more crowded and a little more difficult to interpret, but pulling 3-4 PCs out of all these variables might not be the worst way to go....  

How do all our correlations look when we do this?  

```{r}
preds_from_pca2 <- bind_cols(
  sites_latMedA,
  sites_mediansB,
  sites_trendsA,
  sites_trendsB,
  sites_trendsC
)

chl_df_pca2 <- chl_df |> 
  select(chla_trend) |> 
  bind_cols(preds_from_pca2)

my_corrplot(chl_df_pca2, start_col = 2)

mod2 <- lm(chla_trend ~ ., data = chl_df_pca2)
vif_graph(mod2)
```

Not bad.... some correlation between the **latitude/medians PC2** (turb/chl median & do seasonal amplitude opposing spcond median) and **mediansB-PC2** (nh4 median opposing wspd median) and **trendsC-PC1** (prcp trend opposing % developed, spcond trend, and (less so) no23 trend and chl seasonal amplitude trend).  So we sort of have some relationships between precip/spcond trends and turb/chl, spcond, and do seasonal amplitude?  

```{r}
sub_df2 <- chl_df_pca2 |> 
  select("latMedA-PC2", "mediansB-PC2", "trendsC-PC1")
my_corrplot(sub_df2, 1)
ggpairs(sub_df2)
```

Yeah, I don't like those much.  VIFs were fine though.  

OH YIKES THOUGH, those R^2s - this isn't a good starting point for model selection. Guess we need to keep more axes if we want to do this combination of predictor PCAs??

```{r}
cat("R^2 and adjusted R^2 are: \n")
summary(mod2)$r.squared; summary(mod2)$adj.r.squared
```


What did our first one look like?  

```{r}
cat("R^2 and adjusted R^2 are: \n")
summary(mod1)$r.squared; summary(mod1)$adj.r.squared
```


# One big PCA   

## Sparse PCA  

Sparse PCA forces some loadings to 0, making axes simpler to interpret (see Harrell 2001, section 8.6.1 - starts on p. 175)  

using {pcaPP} package  

```{r}
library(pcaPP)
```


```{r}
# number of components to play with
k = 26

s <- sPCAgrid(preds_main_numeric_scaled, k = k)
plot(s, type = "lines", main = "")
# addscree(s)

# s$loadings
pcs <- s$scores
aic <- numeric(k)


for(i in 1:k){
  ps <- pcs[,1:i]
  aic[i] <- AIC(lm(responses_main$chla_trend ~ ps))
}

plot(1:k, aic, xlab = "number of components used", ylab = "AIC", type = "b")

```

We need a lot of PCs for explanatory power - best is around 22, but another good jump is around 16.  

16 components:  

```{r}
cat("AIC for 16 and 22 components as predictors")
aic[c(16, 22)]

test <- summary(lm(responses_main$chla_trend ~ pcs[,1:16]))

cat("R^2 and adjusted R^2 for the model with 16 predictors are: \n")
test$r.squared; test$adj.r.squared
```


## Regular (non-sparse) PCA  

If we sacrifice some interpretablity, can we get any better explanatory power?  

```{r}
k=26
s2 <- PCAgrid(preds_main_numeric_scaled, k = k)
plot(s2, type = "lines", main = "")
# addscree(s)

# s2$loadings
pcs <- s2$scores
aic <- numeric(k)


for(i in 1:k){
  ps <- pcs[,1:i]
  aic[i] <- AIC(lm(responses_main$chla_trend ~ ps))
}

plot(1:k, aic, xlab = "number of components used", ylab = "AIC", type = "b")
```

Maybe some. Best is still around 17 components, but we might could get away with 13.  

```{r}
cat("AIC for 6, 13, and 17 components as predictors")
aic[c(6, 13, 17)]

test <- summary(lm(responses_main$chla_trend ~ pcs[,1:13]))

cat("R^2 and adjusted R^2 for the model with 13 predictors are: \n")
test$r.squared; test$adj.r.squared
```

Not bad. How about if we drop it from 13 components to 6?  

```{r}
test <- summary(lm(responses_main$chla_trend ~ pcs[,1:6]))

cat("R^2 and adjusted R^2 for the model with 6 predictors are: \n")
test$r.squared; test$adj.r.squared
```

Nope, that cuts our R^2s in half. We'd need at least 13, so we really need to think about interpretability of this option. This option has mostly been off the table since I started playing, but I keep coming back to it as a "what if.....?" - at least I have enough info now to feel good keeping it off the table, and info to show others if it comes back up.   


# Try dropping medians   


Suggestion was that maybe they're so tangled up with latitude/geographic patterns that we don't need them at all? Let's find out what happens to our R^2s when we drop the general water quality/nutrient medians (except for chl and do, which we might want to keep because those are responses)  

```{r}
chl_df_noMedians <- chl_df |> 
  select(-c(nh4_median.log10,
            no23_median.log10,
            po4_median.log10,
            spcond_median,
            totprcp_total,
            turb_median.log10,
            wspd_median))
test <- summary(lm(chla_trend ~ ., data = chl_df_noMedians))

cat("R^2 and adjusted R^2 are: \n")
test$r.squared; test$adj.r.squared
```

Not ideal. Not as bad as trying to use too few PCs above, but not the greatest starting point. So we want to try to incorporate these somehow.  


# One big Medians PCA   

## Single Medians PCA  

```{r}
chl_df_mediansOnly <- chl_df |> 
  select(nh4_median.log10,
            no23_median.log10,
            po4_median.log10,
            spcond_median,
            totprcp_total,
            turb_median.log10,
            wspd_median)

medians_all_pca <- rda(chl_df_mediansOnly)

screeplot(medians_all_pca, type = "lines")
biplot(medians_all_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(medians_all_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_medians_all <- as.data.frame(scores(medians_all_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_medians_all,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_medians_all <- as.data.frame(scores(medians_all_pca, choices = 1:3,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("Medians-PC1", "Medians-PC2", "Medians-PC3"))
```

I'm actually pretty happy with that biplot, and with 3 axes explaining 79% of variation.  

## Single Trends PCA  

```{r}
chl_df_trendsOnly <- chl_df |> 
  select(nh4f_trend,
         no23f_trend,
         po4f_trend,
         precp_trend,
         spcond_trend,
         temp_trend,
         turb_trend
         )

trends_water_pca <- rda(chl_df_trendsOnly)

screeplot(trends_water_pca, type = "lines")
biplot(trends_water_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(trends_water_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_trends_water <- as.data.frame(scores(trends_water_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_trends_water,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_trends_water <- as.data.frame(scores(trends_water_pca, choices = 1:4,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("Trends-PC1", "Trends-PC2", "Trends-PC3", "Trends-PC4"))
```

I don't really like how many axes that takes; would rather get a combination that only needs two, *maybe* three.  

## Two Trends PCAs  

The first iteration of grouped PCAs had 3 groups of trends. Here, because of some of the clustering results, I'm trying to combine 'trends a' and 'trends b' from above, and leaving 'trends c' alone. Let's see how well that combination works.  

```{r}
trendsAB_df <- chl_df |> 
  select(turb_trend,
         temp_trend,
         temp_seasAmp_trend,
         nh4f_trend,
         po4f_trend,
         dailyPAR_trend,
         domgl_seasAmp_trend)
trendsAB_pca <- rda(trendsAB_df)

screeplot(trendsAB_pca, type = "lines")
biplot(trendsAB_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(trendsAB_pca))
knitr::kable(eigs[, 1:5],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_trendsAB <- as.data.frame(scores(trendsAB_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_trendsAB,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_trendsAB <- as.data.frame(scores(trendsAB_pca, choices = 1:4,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("trendsAB-PC1", "trendsAB-PC2", "trendsAB-PC3", "trendsAB-PC4"))
```

Again, requires 4 PCs. Not wild about that.  

## Correlations - single trend PCA  

Let's check out correlations etc. between the medians and both versions of the trend PCAs. Add latitude PCA and others back in too. There may be some variables that didn't go into PCAs this time (e.g. dailyPAR trend) because I didn't immediately see how they fit, so I'll pull them back in too.   

**Medians and Single Trends PCA**  

```{r}
# names of variables used in all of the following
pca3_names <- c(names(lat_df),
                names(chl_df_mediansOnly),
                names(chl_df_trendsOnly))

preds_from_pca3 <- bind_cols(
  sites_lat,
  sites_medians_all,
  sites_trends_water
)

remaining_predictors <- chl_df |> 
  select(-chla_trend,
         -any_of(pca3_names))


chl_df_pca3 <- chl_df |> 
  select(chla_trend) |> 
  bind_cols(preds_from_pca3) |> 
  bind_cols(remaining_predictors)

my_corrplot(chl_df_pca3, start_col = 2)

mod3 <- lm(chla_trend ~ ., data = chl_df_pca3)
vif_graph(mod3)

cat("R^2 and adjusted R^2 are: \n")
summary(mod3)$r.squared; summary(mod3)$adj.r.squared

```

Medians PC1 has a lot of correlations - with trends (higher PCs only and PAR trend, weirdly), DO seasonality, chl median, and chl seasonality.  

Medians PC3 has a lot of correlations with the others as well.  

VIFs are still okay but a little higher than before.  

R^2s are lower than I'd like.  

## Correlations - two trend PCAs 

I don't think splitting out the trends into 2 PCAs is going to improve the correlations seen with the single trend PCA, as long as we keep medians together. But let's find out.  

```{r}
# names of variables used in all of the following
pca4_names <- c(names(lat_df),
                names(chl_df_mediansOnly),
                names(trendsAB_df),
                names(trendsC_df))

preds_from_pca4 <- bind_cols(
  sites_lat,
  sites_medians_all,
  sites_trendsAB,
  sites_trendsC
)

remaining_predictors <- chl_df |> 
  select(-chla_trend,
         -any_of(pca4_names))


chl_df_pca4 <- chl_df |> 
  select(chla_trend) |> 
  bind_cols(preds_from_pca4) |> 
  bind_cols(remaining_predictors)

my_corrplot(chl_df_pca4, start_col = 2)

mod4 <- lm(chla_trend ~ ., data = chl_df_pca4)
vif_graph(mod4)

cat("R^2 and adjusted R^2 are: \n")
summary(mod4)$r.squared; summary(mod4)$adj.r.squared

```

Correlations with PC1 of the medians don't look so bad anymore. Now it's PC2. Those with PC1 are chl median and DO seasonal amplitude (which is itself a median, so maybe it could go into the Medians PCA). Think I could live with most of these, actually.  

Not much improved over the single trends PCA version, but at least now the biggest VIF belongs to median chl. Maybe I should go ahead and add both that and DO seasonality to the medians PCA.  


# One bigger medians PCA   

Keep trends PCAs as above, and see what happens when we add chl median and DO seasonality into the median PCA.  

## Single Medians PCA  

```{r}
chl_df_mediansOnly_big <- chl_df |> 
  select(nh4_median.log10,
            no23_median.log10,
            po4_median.log10,
            spcond_median,
            totprcp_total,
            turb_median.log10,
            wspd_median,
         chla_median.log10,
         domgl_seasAmp)

medians_all_pca_big <- rda(chl_df_mediansOnly_big)

screeplot(medians_all_pca_big, type = "lines")
biplot(medians_all_pca_big,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(medians_all_pca_big))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)

scores_medians_big <- as.data.frame(scores(medians_all_pca_big, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_medians_big,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_medians_big <- as.data.frame(scores(medians_all_pca_big, choices = 1:4,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("Medians-PC1", "Medians-PC2", "Medians-PC3", "Medians_PC4"))
```

Back to needing 4 PCs, which I'm not wild about for future variable selection.  

## Check correlations - single trend PCA  

```{r}
# names of variables used in all of the following
pca5_names <- c(names(lat_df),
                names(chl_df_mediansOnly_big),
                names(chl_df_trendsOnly))

preds_from_pca5 <- bind_cols(
  sites_lat,
  sites_medians_big,
  sites_trends_water
)

remaining_predictors <- chl_df |> 
  select(-chla_trend,
         -any_of(pca5_names))


chl_df_pca5 <- chl_df |> 
  select(chla_trend) |> 
  bind_cols(preds_from_pca5) |> 
  bind_cols(remaining_predictors)

my_corrplot(chl_df_pca5, start_col = 2)

mod5 <- lm(chla_trend ~ ., data = chl_df_pca5)
vif_graph(mod5)

cat("R^2 and adjusted R^2 are: \n")
summary(mod5)$r.squared; summary(mod5)$adj.r.squared

```

Now we've got latitude with our medians again. I think chl and do may need to go into latitudes rather than the medians - which does give us a better medians PCA.  

## Correlations - two trend PCAs 

 
```{r}
# names of variables used in all of the following
pca6_names <- c(names(lat_df),
                names(chl_df_mediansOnly_big),
                names(trendsAB_df),
                names(trendsC_df))

preds_from_pca6 <- bind_cols(
  sites_lat,
  sites_medians_big,
  sites_trendsAB,
  sites_trendsC
)

remaining_predictors <- chl_df |> 
  select(-chla_trend,
         -any_of(pca6_names))


chl_df_pca6 <- chl_df |> 
  select(chla_trend) |> 
  bind_cols(preds_from_pca6) |> 
  bind_cols(remaining_predictors)

my_corrplot(chl_df_pca6, start_col = 2)

mod6 <- lm(chla_trend ~ ., data = chl_df_pca6)
vif_graph(mod6)

cat("R^2 and adjusted R^2 are: \n")
summary(mod6)$r.squared; summary(mod6)$adj.r.squared

```

Medians correlating some with trends again in this version. Again really no improvement in R^2s.  


# 2 Groups to start  

Here, I'll try combining latitude with all the medians, and making a separate group with all of the trends. I'll..... pick off variables until we get a decent amount explained in each PCA, and then try combinations of the ones that were removed? Not sure how well this is going to work, or if there's a way to go other than brute forcing.  

## Latitude & Medians  

Including seasonal amplitudes in this, and % developed.  

```{r}
lat_meds_df <- chl_df |> 
  select(latitude,
         chla_median.log10,
         chla_seasAmp,
         dailyPAR_median,
         domgl_seasAmp,
         nh4_median.log10,
         no23_median.log10,
         po4_median.log10,
         spcond_median,
         temp_median,
         temp_seasAmp,
         totprcp_total,
         turb_median.log10,
         wspd_median,
         pctDev.log10)
lat_meds_pca <- rda(lat_meds_df)

screeplot(lat_meds_pca, type = "lines")
biplot(lat_meds_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))
```

From the biplot, I'd think we can remove % developed, po4 median, possibly nh4 median, possibly total precip, possibly temp seasonal amplitude, possibly chla seasonal amplitude, though the latter tracks pretty well with latitude

```{r}

eigs <- summary(eigenvals(lat_meds_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)
```


### Try again  

Keeping precip because keeping spcond. Removed % developed, po4 median, nh4 median.

```{r}
lat_meds_df <- chl_df |> 
  select(latitude,
         chla_median.log10,
         chla_seasAmp,
         dailyPAR_median,
         domgl_seasAmp,
         no23_median.log10,
         spcond_median,
         temp_median,
         temp_seasAmp,
         totprcp_total,
         turb_median.log10
         )
lat_meds_pca <- rda(lat_meds_df)

screeplot(lat_meds_pca, type = "lines")
biplot(lat_meds_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(lat_meds_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)
```

Could probably get away with 3 axes, but does it improve by removing NO23 and temp seasonality?  

### Try again  

```{r}
lat_meds_df <- chl_df |> 
  select(latitude,
         chla_median.log10,
         chla_seasAmp,
         dailyPAR_median,
         domgl_seasAmp,
         spcond_median,
         temp_median,
         totprcp_total,
         turb_median.log10
         )
lat_meds_pca <- rda(lat_meds_df)

screeplot(lat_meds_pca, type = "lines")
biplot(lat_meds_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(lat_meds_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)
```


Nah, that didn't improve it.  

What if we just do latitude, chl seasonality, PAR, and temp  

### This one might work  

Pulling conductivity in or out makes a difference between 2 and 3 axes needed. So drop conductivity and see if we can add anything else back in. 

Can probably get away with 2, maybe 3 axes, including chl and turb medians. (probably want to include 3 and let the model selection choose for us on the 3rd?)

```{r}
lat_meds_df <- chl_df |> 
  select(latitude,
         chla_seasAmp,
         dailyPAR_median,
         temp_median,
         chla_median.log10,
         turb_median.log10
         )
lat_meds_pca <- rda(lat_meds_df)

screeplot(lat_meds_pca, type = "lines")
biplot(lat_meds_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(lat_meds_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)
```


### One more try at pulling 2 axes from more than 4 of these variables  

```{r}
lat_meds_df <- chl_df |> 
  select(latitude,
         chla_seasAmp,
         dailyPAR_median,
         domgl_seasAmp,
         temp_median,
         temp_seasAmp,
         totprcp_total
         )
lat_meds_pca <- rda(lat_meds_df)

screeplot(lat_meds_pca, type = "lines")
biplot(lat_meds_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(lat_meds_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)
```

# Disregard latitude and try water/nutrient medians  

```{r}
water_medians <- chl_df |> 
  select(chla_median.log10,
         turb_median.log10,
         spcond_median,
         nh4_median.log10,
         no23_median.log10,
         po4_median.log10)

water_meds_pca <- rda(water_medians)

screeplot(water_meds_pca, type = "lines")
biplot(water_meds_pca,
       choices = c(1, 2),
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(water_meds_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)
```

Doesn't work very well and I don't see an obvious thing to remove.  

```{r}
water_medians <- chl_df |> 
  select(chla_median.log10,
         # turb_median.log10,
         spcond_median,
         nh4_median.log10,
         no23_median.log10,
         po4_median.log10)

water_meds_pca <- rda(water_medians)

screeplot(water_meds_pca, type = "lines")
biplot(water_meds_pca,
       choices = c(1, 2),
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(water_meds_pca))
knitr::kable(eigs[, 1:6],
             caption = "Variance explained by PC axes",
             digits = 4)
```


# Try building up from latitude PCA again  

If we only use the latitude PCA, is the rest of the collinearity acceptable? Just do that one, then examine clustering and corrplots.  

```{r}
lat_df <- chl_df |> 
  select(latitude,
         temp_median,
         temp_seasAmp,
         dailyPAR_median,
         chla_seasAmp,
         totprcp_total)
lat_pca <- rda(lat_df)

screeplot(lat_pca, type = "lines")
biplot(lat_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(lat_pca))
knitr::kable(eigs[, 1:4],
             caption = "Variance explained by PC axes",
             digits = 4)

# loadings
scores_lat <- as.data.frame(scores(lat_pca, choices = 1:4,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_lat,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_lat <- as.data.frame(scores(lat_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("Lat-PC1", "Lat-PC2"))
```

```{r}
remaining_predictors <- preds_main_numeric_scaled |> 
  select(-all_of(names(lat_df)))
new_combnd <- bind_cols(sites_lat, remaining_predictors)
my_corrplot(new_combnd, 1)
```

```{r}
some_medians <- preds_main_numeric_scaled |> 
  select(no23_median.log10, 
         nh4_median.log10,
         po4_median.log10,
         spcond_median)  
some_meds_pca <- rda(some_medians)

screeplot(some_meds_pca, type = "lines")
biplot(some_meds_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(some_meds_pca))
knitr::kable(eigs[, 1:3],
             caption = "Variance explained by PC axes",
             digits = 4)

# loadings
scores_some_meds <- as.data.frame(scores(some_meds_pca, choices = 1:2,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_some_meds,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_some_meds <- as.data.frame(scores(some_meds_pca, choices = 1:2,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("MedsA-PC1", "MedsA-PC2"))
```

```{r}
remaining_predictors <- preds_main_numeric_scaled |> 
  select(-all_of(names(some_medians)),
         -all_of(names(lat_df)))
new_combnd <- bind_cols(sites_lat, sites_some_meds, remaining_predictors)
my_corrplot(new_combnd, 1)
plot(varclus(as.matrix(new_combnd)))
```

Then it's back to combining the latitude and medians PCA, and.... see above. Around and around we go.  

```{r}
combnd_lats_meds <- bind_cols(lat_df, some_medians)
combnd_latsMeds_pca <- rda(combnd_lats_meds)

screeplot(combnd_latsMeds_pca, type = "lines")
biplot(combnd_latsMeds_pca,
       display = c("sites",
                   "species"),
       type = c("text",
                "text"))

eigs <- summary(eigenvals(combnd_latsMeds_pca))
knitr::kable(eigs[, 1:5],
             caption = "Variance explained by PC axes",
             digits = 4)

# loadings
scores_combnd_latMeds <- as.data.frame(scores(combnd_latsMeds_pca, choices = 1:5,
                     display = "species",
                     scaling = 0))
knitr::kable(scores_combnd_latMeds,
             caption = "unscaled loadings onto PC axes",
             digits = 4)


# site scores - to add to chl predictor df before the next round
sites_LatMeds <- as.data.frame(scores(combnd_latsMeds_pca, choices = 1:3,
                     display = "sites",
                     scaling = 0)) |> 
  set_names(c("LatMeds-PC1", "LatMeds-PC2", "LatMeds-PC3"))
```

Need 3 or 4 if we go this route.    


```{r}
remaining_predictors <- preds_main_numeric_scaled |> 
  select(-all_of(names(combnd_lats_meds)))
new_combnd <- bind_cols(sites_LatMeds, remaining_predictors)
my_corrplot(new_combnd, 1)
plot(varclus(as.matrix(new_combnd)))
```

Going around in circles.  

# Latitude, Seasonality, Nutrients  

Maybe break out seasonality medians and trends toge
