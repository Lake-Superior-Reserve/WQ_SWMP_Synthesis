---
title: "Trends Script Outline"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      error = TRUE)

library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(lubridate)
library(mgcv)
library(gt)
library(gtsummary)


source(here::here("helper_files", "definitions.R"))
source(here::here("helper_files", "functions.R"))

load(here::here("Data", "QAQCd_monthly_byType", "SWMP_monthlyWQ.RData"))
load(here::here("Data", "QAQCd_monthly_byType", "SWMP_monthlyNUT.RData"))
```

We will have 3 chunks of data: WQ, MET, NUT. For each type:  

1.  Load data frame  
2.  Create grid of station/parameter combinations.  
3.  Do appropriate subsetting, based on length of dataset and depth.  
    a.  in `definitions.R` file, an object named `stns_wq_nut_d10` is defined. This vector consists of 105 stations that are labelled "Active", have starting dates before January of 2013, and exist for both WQ and NUT data types.    
4.  Loop through parameters:  
    a.  for each parameter, loop through stations
        i.  run appropriate bam model  
        ii.  extract necessary model info    
        iii.  add model info to type-parameter list
    b.  bind the list to get one data frame per parameter
    c.  make that data frame part of a 'type' output list  
5.  At end of that loop, will have a 'type' list with separate data frames for each parameter. Bind them into one big data frame.  
6.  Get seasonality info on same row as slope coefficient.  
7.  Bind rows on WQ and NUT  
8.  Substring the first 5 letters of station names, so WQ and NUT stations can be associated with each other for station-level reports  
9.  Make sure it's clear that the slope for nutrients is the slope for log10(nut), not raw nut  
10.  Write out the results!  


# Setup  

Subset wq and nut data frames; create param grids.  

Prioritized parameters:
Responses:  NO3/2, NH4, PO4, Chla, DO, DIN:DIP, proportion of DO data below 2 mg/L; proportion of DO data below 5 mg/L; proportion of chla data above ___
Driver variables: Temp (water and air), Precipitation, Sal, Cond, Stratification, Turbidity, PAR  

First join wq and nut, so only have to write one loop? No, I wrote separate bam functions for them, drat.    

```{r}
dat_wq <- wq |> 
  filter(station %in% paste0(stns_wq_nut_d10, "wq")) |> 
  mutate(do_proportion_below2 = round(doLessThan2_total / doLessThan2_nValid, 4),
         do_proportion_below5 = round(doLessThan5_total / doLessThan5_nValid, 4)) |> 
  select(station, year, month, 
         do_pct_median, do_mgl_median,
         temp_median, spcond_median, 
         sal_median, turb_median,
         do_proportion_below2,
         do_proportion_below5)

# may need to treat DO proportions differently from others - not gaussian, but beta

dat_nut <- nut |> 
  filter(station %in% paste0(stns_wq_nut_d10, "nut")) |> 
  select(station, year, month, 
         chla_n, po4f,
         nh4f, no23f,
         chla_n_cens, po4f_cens,
         nh4f_cens, no23f_cens) |> 
  mutate(DIN_to_DIP = (nh4f + no23f) / po4f,
         DIN_to_DIP_cens = case_when(nh4f_cens + no23f_cens + po4f_cens == 0 ~ 0,
                                     .default = 1))

# DIN_to_DIP may also need to be treated in a non-gaussian way
```

```{r}
# avoiding all proportion/ratio data at this point
wq_grid <- expand.grid(station = unique(dat_wq$station), 
                       param = names(dat_wq[4:9]))
nut_grid <- expand.grid(station = unique(dat_nut$station), 
                       param = names(dat_nut[4:11]))
```

# WQ  

```{r}
# wq_grid <- wq_grid[1:3, ]

# set up outputs
trends_out <- list()


# run the loop
for(i in 1:nrow(wq_grid)){
  stn <- as.character(wq_grid$station[i])
  param <- as.character(wq_grid$param[i])
  
  # subset to that stn/param combo
  tmp <- subset_df("wq", dat_wq, stn, param)
  
  # if the below statement is true, there was an error in the model
  # and we need to do something, and move to the next item in the loop
  # if it was false, we can move on
  if(inherits(try(run_bam_wq(tmp), silent = TRUE), "try-error")){
    out <- data.frame(station = stn,
                      parameter = param,
                      model_error = TRUE)  
  } else {
    # run model
    bam_out <- run_bam_wq(tmp)
    
    # still need to capture autocorrelation parameters- that will require edits to the function
    
    bam_tidy <- gtsummary::tidy_gam(bam_out, conf.int = TRUE) |> 
      select(-parametric) |> 
      mutate(station = stn,
             parameter = param,
             term = case_match(term,
                               "(Intercept)" ~ "Intercept",
                               "dec_date" ~ "Trend (/yr)",
                               "s(month)" ~ "Seasonality")) |> 
      select(station, parameter, everything())
    
    bam_trend <- bam_seas <- bam_tidy |> 
      filter(term == "Trend (/yr)") |> 
      select(station,
             parameter,
             "Slope" = estimate,
             std.error,
             conf.low,
             conf.high,
             statistic,
             p.value)
    
    bam_seas <- bam_tidy |> 
      filter(term == "Seasonality") |> 
      select(station,
             parameter,
             "Seas_edf" = edf,
             "Seas_ref.df" = ref.df,
             "Seas_stat" = statistic,
             "Seas_p.val" = p.value)
    
    bam_r2 <- data.frame(
      station = stn,
      parameter = param,
      R2_adj = summary(bam_out)$r.sq,
      Dev_expl = summary(bam_out)$dev.expl
    )
    
    out <- dplyr::left_join(bam_trend, bam_seas) |> 
      dplyr::left_join(bam_r2) |> 
      mutate(model_error = FALSE)
    
  }
  
  trends_out[[i]] <- out
}

trends_df <- dplyr::bind_rows(trends_out) |> 
  mutate(sig_trend = case_when(p.value <= 0.05 ~ "yes",
                               .default = "no"),
         sig_seasonality = case_when(Seas_p.val <= 0.05 ~ "yes",
                                     .default = "no"))
```


It's going through do_pct_median first, and errors on grbgbwq, with this error: "more knots than unique data values is not allowed". This looks like a station with regular gaps in winter, so maybe can't use 12 knots because all 12 months don't exist in the dataset?? Wonder how to fix this?  


Managed to skip this, and all seem to be ice stations.  

```{r}
trends_df |> 
  filter(model_error == TRUE) |> 
  select(station) |> 
  unique()
```


```{r}
# how to reorder stations by slope for each parameter?  
ggplot(trends_df, aes(x = station, y = Slope)) +
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high,
                      col = sig_trend)) +
  geom_hline(yintercept = 0) +
  facet_wrap(~parameter, scales = "free_y") +
  labs(title = "Slopes for all stations",
       col = "Significant slope?")
```

```{r}
ggplot(trends_df) +
  geom_histogram(aes(x = Slope,
                     fill = parameter),
                 bins = 30,
                 col = "gray20",
                 alpha = 0.8) +
  facet_wrap(~parameter, scales = "free") +
  geom_vline(xintercept = 0,
             linewidth = 1) +
  theme(legend.position = "none") +
  labs(title = "Histograms of slopes for each parameter")
```

```{r}
seas_df <- trends_df |> 
  summarize(.by = c(parameter, sig_seasonality),
            n()) |> 
  pivot_wider(names_from = sig_seasonality,
              values_from = `n()`) |> 
  mutate(no = -1*no)

ggplot(seas_df) +
  geom_segment( aes(x=parameter, xend=parameter, y=no, yend=yes)) +
  geom_point( aes(x=parameter, y=no, color="seasonal"), size=3 ) +
  geom_point( aes(x=parameter, y=yes, color="not seasonal"), size=3 ) +
  geom_hline(yintercept = 0) +
  scale_color_brewer(palette = "Set1") +
  coord_flip()+
  theme(
    legend.position = "none",
  ) +
  xlab("") +
  ylab("# of stations displaying seasonality")
```


# NUTs  

```{r}
# set up outputs
trends_out <- list()


# run the loop
for(i in 1:nrow(nut_grid)){
  stn <- as.character(nut_grid$station[i])
  param <- as.character(nut_grid$param[i])
  
  # subset to that stn/param combo
  tmp <- subset_df("nut", dat_nut, stn, param)
  
  # if the below statement is true, there was an error in the model
  # and we need to do something, and move to the next item in the loop
  # if it was false, we can move on
  if(inherits(try(run_bam_nut(tmp), silent = TRUE), "try-error")){
    out <- data.frame(station = stn,
                      parameter = param,
                      model_error = TRUE)  
  } else {
    # run model
    bam_out <- run_bam_nut(tmp)
    
    # still need to capture autocorrelation parameters- that will require edits to the function
    
    bam_tidy <- gtsummary::tidy_gam(bam_out, conf.int = TRUE) |> 
      select(-parametric) |> 
      mutate(station = stn,
             parameter = param,
             term = case_match(term,
                               "(Intercept)" ~ "Intercept",
                               "dec_date" ~ "Trend (/yr)",
                               "s(month)" ~ "Seasonality")) |> 
      select(station, parameter, everything())
    
    bam_trend <- bam_seas <- bam_tidy |> 
      filter(term == "Trend (/yr)") |> 
      select(station,
             parameter,
             "Slope" = estimate,
             std.error,
             conf.low,
             conf.high,
             statistic,
             p.value)
    
    bam_seas <- bam_tidy |> 
      filter(term == "Seasonality") |> 
      select(station,
             parameter,
             "Seas_edf" = edf,
             "Seas_ref.df" = ref.df,
             "Seas_stat" = statistic,
             "Seas_p.val" = p.value)
    
    bam_r2 <- data.frame(
      station = stn,
      parameter = param,
      R2_adj = summary(bam_out)$r.sq,
      Dev_expl = summary(bam_out)$dev.expl
    )
    
    out <- dplyr::left_join(bam_trend, bam_seas) |> 
      dplyr::left_join(bam_r2) |> 
      mutate(model_error = FALSE)
    
  }
  
  trends_out[[i]] <- out
}

trends_nut <- dplyr::bind_rows(trends_out) |> 
  mutate(sig_trend = case_when(p.value <= 0.05 ~ "yes",
                               .default = "no"),
         sig_seasonality = case_when(Seas_p.val <= 0.05 ~ "yes",
                                     .default = "no"))
```


Again skipped station/param combinations that didn't work. There are more than just ice stations.  


```{r}
trends_nut |> 
  filter(model_error == TRUE) |> 
  select(station, parameter) |> 
  summarize(.by = station,
            parameters = paste(unique(parameter), collapse = "; ")) |> 
  arrange(station) |> 
  gt(caption = "Nutrient stations where the model did not run")
```


```{r}
# how to reorder stations by slope for each parameter?  
ggplot(trends_nut, aes(x = station, y = Slope)) +
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high,
                      col = sig_trend)) +
  geom_hline(yintercept = 0) +
  facet_wrap(~parameter, scales = "free_y") +
  labs(title = "Slopes for all stations",
       col = "Significant slope?")
```

```{r}
ggplot(trends_nut) +
  geom_histogram(aes(x = Slope,
                     fill = parameter),
                 bins = 30,
                 col = "gray20",
                 alpha = 0.8) +
  facet_wrap(~parameter, scales = "free") +
  geom_vline(xintercept = 0,
             linewidth = 1) +
  theme(legend.position = "none") +
  labs(title = "Histograms of slopes for each parameter")
```

```{r}
seas_nut <- trends_nut |> 
  summarize(.by = c(parameter, sig_seasonality),
            n()) |> 
  pivot_wider(names_from = sig_seasonality,
              values_from = `n()`) |> 
  mutate(no = -1*no)

ggplot(seas_nut) +
  geom_segment( aes(x=parameter, xend=parameter, y=no, yend=yes)) +
  geom_point( aes(x=parameter, y=no, color="seasonal"), size=3 ) +
  geom_point( aes(x=parameter, y=yes, color="not seasonal"), size=3 ) +
  geom_hline(yintercept = 0) +
  scale_color_brewer(palette = "Set1") +
  coord_flip()+
  theme(
    legend.position = "none",
  ) +
  xlab("") +
  ylab("# of stations displaying seasonality")
```





# Other thoughts  

Present results  

-  graphically:  
    -  stations along x-axis, grouped and colored by region (need to make stn name a factor)  
    -  y-axis will be rate of change. geom_point for slope estimate, geom_errorbar for CI.  
    -  geom_hline for 0.  
    -  facet_wrap by parameter. free_y scales.  
-  tables for each station (Reserves will be interested in this):  
    -  group df by station code, then table with params as rows and the rest as columns.  
    -  no extra shaping, just subsetting.  
    


