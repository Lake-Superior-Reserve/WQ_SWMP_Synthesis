---
title: "Long-Term Trend Analyses - GAM testing"
output: 
  html_document:
    toc: true
    toc_float: true
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      error = TRUE)
```

```{r}
library(dplyr)
library(lubridate)
library(broom)
library(mgcv)
library(NADA2)
```


Trying to see if I can really run the GAM that I want to run to incorporate everything:  

-  linear time trend  
-  seasonal cycling  
-  autocorrelation of errors  
-  censored data  

Will use decimal date, so trends will be per year. Will use log-transformed nutrient concentrations.    

# Data  

Will work with a few parameter/station combos; all from aggregated monthly files:  

**Nutrients**:  

-  `cbmipnut` PO4 - seems to have a negative trend  
-  `cbvginut` NO23 - MDL increases; looks like the nutrient itself probably doesn't, and I want to see what the GAM gives us.  
-  `gndhsnut` NH4F - seems to be decreasing, even with decreasing MDL.  


**Water Quality**:  

-  `gndpcwq` spcond_median seems to be decreasing (?)  
-  `gndbcwq` - cdepth_median seems to be increasing  
-  `niwolwq` - do-pct - doesn't seem to be changing (visually anyway)  


```{r}
load(here::here("Data", "QAQCd_monthly_byType", "SWMP_monthlyNUT.RData"))
load(here::here("Data", "QAQCd_monthly_byType", "SWMP_monthlyWQ.RData"))

stns <- c("cbmipnut", "cbvginut", "gndhsnut",
          "gndpcwq", "gndbcwq", "niwolwq")

nut <- filter(nut, station %in% stns) %>% 
  mutate(dec_date = decimal_date(ymd(paste(year, month, "15", sep = "-"))))
wq <- filter(wq, station %in% stns) %>% 
  mutate(dec_date = decimal_date(ymd(paste(year, month, "15", sep = "-"))))

# nut data sets  
cbmip <- filter(nut, station == "cbmipnut") %>% 
  select(dec_date, 
         year,
         month,
         nut = po4f,
         cens = po4f_cens) %>% 
  mutate(lognut = log(nut),
         cens2 = case_when(cens == 0 ~ lognut,    # extra censoring column for gam
                           cens == 1 ~ -Inf))

cbvgi <- filter(nut, station == "cbvginut") %>% 
  select(dec_date, 
         year,
         month,
         nut = no23f,
         cens = no23f_cens) %>% 
  mutate(lognut = log(nut),
         cens2 = case_when(cens == 0 ~ lognut,    # extra censoring column for gam
                           cens == 1 ~ -Inf))

gndhs <- filter(nut, station == "gndhsnut") %>% 
  select(dec_date, 
         year,
         month,
         nut = nh4f,
         cens = nh4f_cens) %>% 
  mutate(lognut = log(nut),
         cens2 = case_when(cens == 0 ~ lognut,    # extra censoring column for gam
                           cens == 1 ~ -Inf))


# wq data sets
gndpc <- filter(wq, station == "gndpcwq") %>% 
  select(dec_date, 
         year,
         month,
         param = spcond_median)

gndbc <- filter(wq, station == "gndbcwq") %>% 
  select(dec_date, 
         year,
         month,
         param = cdepth_median)

niwol <- filter(wq, station == "niwolwq") %>% 
  select(dec_date, 
         year,
         month,
         param = cdepth_median)
```

# CBMIPNUT {.tabset}  

PO4 - seems to (visually) have a negative trend. No censoring.  

## Simple Regression  

```{r}
cbmip_lm <- lm(lognut ~ dec_date, data = cbmip)
summary(cbmip_lm)
acf(residuals(cbmip_lm))[1]
```


## Censored Regression  

Censored regression using the `NADA2` package doesn't work with this station because there are no censored values.  



## GAM w/censoring  

This slope should be the same as that from censored regression - which in this case should be the same as from simple linear regression.  




## GAM w/seasonality only  

This slope will be most comparable to the simple regression model.  

Seasonal term is highly significant. Linear trend slope looks the same as before, though standard error is a bit smaller.  R^2 went up from about 0.2 (linear model) to about 0.5.  

Even after accounting for seasonality, there's autocorrelation in the residuals; much less though.  

```{r}
cbmip_gam_seas <- gam(lognut ~ dec_date + s(month, bs = "cc", k = 12),
                  data = cbmip)
summary(cbmip_gam_seas)
acf(residuals(cbmip_gam_seas))[1]
```


## GAM w/cens + seasonality  

```{r}
cbmip$lognut_mat <- cbind(cbmip$lognut, cbmip$cens2)
cbmip_gam_censseas <- gam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  data = cbmip,
                  method = "REML")
summary(cbmip_gam_censseas)
acf(residuals(cbmip_gam_censseas))[1]
```

Similar slope to all that came before with this station. 


## bam  

1. make sure all year-months are included  
2. create a column that will be TRUE at the first row of independent sections of AR1 correlation (e.g. when time series has been broken)  

```{r}
cbmip$lognut_mat <- cbind(cbmip$lognut, cbmip$cens2)
glimpse(cbmip)
min(cbmip$year); max(cbmip$year)
all_yearmonths <- expand.grid(year = min(cbmip$year):max(cbmip$year), 
                              month = 1:12) |> 
  arrange(year, month)
cbmip2 <- left_join(all_yearmonths, cbmip) |> 
  mutate(dec_date = decimal_date(ymd(paste(year, month, "15", sep = "-"))),
         restart = case_when(is.na(lag(nut)) & !is.na(nut) ~ TRUE,
                             .default = FALSE)
         )
# remove first months if necessary
cbmip2 <- cbmip2[min(which(!is.na(cbmip2$nut))):nrow(cbmip2), ]


```

```{r}
# more like the gam output - not discrete, not freml - just to verify bam generally
cbmip_bam_censseas01 <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  data = cbmip2,
                  method = "REML")
summary(cbmip_bam_censseas01)
```


```{r}
# bam on the original data frame, which didn't have rows for missing months
cbmip_bam_censseas001 <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  data = cbmip,
                  discrete = TRUE,
                  method = "fREML")
summary(cbmip_bam_censseas001)


cbmip2$lognut_mat <- cbind(cbmip2$lognut, cbmip2$cens2)

# now bam on the data frame that includes missing months
# shouldn't change the output
cbmip_bam_censseas <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  data = cbmip2,
                  discrete = TRUE,
                  method = "fREML")
summary(cbmip_bam_censseas)
# and, doesn't change the output, confirmed


# now add in the AR-start thing, but not rho yet
cbmip_bam_censseasARstart <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  data = cbmip2,
                  discrete = TRUE,
                  AR.start = restart,
                  method = "fREML")
summary(cbmip_bam_censseasARstart)
# output looks the same, now look at residuals

acf(residuals(cbmip_bam_censseasARstart))[1]
# is that different from when I didn't specify AR start?
acf(residuals(cbmip_bam_censseas))[1]
# no
# but it is the standardized residuals: std.rsd that should be better
# ...and we don't have standardized residuals yet because we haven't provided rho

# provide rho - it was 0.28 from the acfs above
cbmip_bam_censseasAR_full <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  data = cbmip2,
                  discrete = TRUE,
                  AR.start = restart,
                  rho = 0.28,
                  method = "fREML")
summary(cbmip_bam_censseasAR_full)
# estimate for dec_date went from -0.0835 to -0.0813 - pretty similar
# se for dec_date went up from 0.0087 to 0.0113 - seems appropriate

# did that rho give us what we needed?
acf(cbmip_bam_censseasAR_full$std.rsd)[1]
# YEEEEEEEEEESSSSSSS!!!!!!!

```

```{r}
# run bam with an almost-0 rho, using AR.start
# (in case missing/unevenly spaced data messed up the true ACF)
# then get the lag-1 acf estimate
# to use in what will be the "real" bam
test <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
            family = cnorm(),
            discrete = TRUE,
            AR.start = restart,
            rho = 0.0001,
            data = cbmip2,
            method = "fREML")
summary(test)
acf(residuals(test))[1]
acf(test$std.rsd)[1]

rho_test <- acf(test$std.rsd)
use_this_rho <- rho_test$acf[2]  # 2nd position is lag 1

# then this is the real model to use results from
test2 <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
             family = cnorm(),
             discrete = TRUE,
             AR.start = restart,
             rho = use_this_rho,  # calculated from the first time
             data = cbmip2,
             method = "fREML")
acf(test2$std.rsd)[1]
summary(test2)


acf.out <- acf(test2$std.rsd, ci.type = "white")


# cis in the plot:
# qnorm((1 + ci)/2)/sqrt(x$n.used)
# from https://stats.stackexchange.com/questions/211628/how-is-the-confidence-interval-calculated-for-the-acf-function

# would want to adjust rho when it is outside +/- the following:
qnorm((1 + 0.95)/2)/sqrt(acf.out$n.used)

# this stackexchange post has some info from Hyndman & Athanasopoulos about the theory/math:
# https://stats.stackexchange.com/questions/49571/understanding-the-blue-dotted-lines-in-an-acf-from-r
```

I'm still the tiniest bit concerned that the `acf` is still inaccurate, because the lag 1 value matched between models where I used `AR.start` and where I didn't. Maybe trying this on some other datasets will reassure me.  


What results do we want to pull out of our final model?  `gtsummary::tidy_gam()` seems to pull out everything I want! At least for rate of change and info about seasonality.  

```{r}
library(gt)
library(gtsummary)  # note this didn't work until I'd also installed broom.mixed

tidy_gam(cbmip_bam_censseasAR_full,
         conf.int = TRUE) 

tidy_gam(cbmip_bam_censseasAR_full,
         conf.int = TRUE) |> 
  filter(term != "(Intercept)") |> 
  select(term, estimate, std.error, conf.low, conf.high,
         statistic, p.value, edf, ref.df) |> 
  gt() |> 
  fmt_number(c("estimate", "std.error", "p.value"),
               decimals = 3) |> 
  fmt_number(c("conf.low", "conf.high"),
             decimals = 3) |> 
  fmt_number(c("statistic", "edf"), 
             decimals = 1) |> 
  sub_missing(missing_text = "--")


tbl_regression(cbmip_bam_censseasAR_full,
               tidy_fun = tidy_gam) |> 
  add_glance_source_note()
```


-  slope and std error for dec_date - change/year
-  p-value for dec_date  
-  edf, ref.df, F, p for seasonal smooth  
    -  I'm imagining some sort of "seasonality was significant for X of the Y stations" for each parameter summary - e.g., DO is almost always seasonal; turbidity maybe wouldn't be; nutrients up in the air....  
    -  maybe a dumbbell plot, where each line is a parameter, and one side of the graph is the number of stations with significant seasonality, and the other side is without significant seasonality. Like this population pyramid, but with lollipops instead of bars: https://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html#Population%20Pyramid  or this lollipop plot, but centered on 0: https://r-graph-gallery.com/303-lollipop-plot-with-2-values.html  
-  R^2 adj; deviance explained  
-  what is the number in parentheses at the top of the summary: Family: cnorm(0.703) - maybe that number? Must be `theta` - from the help file: "theta -
log standard deviation parameter. If supplied and positive then taken as a fixed value of standard deviation (not its log). If supplied and negative taken as negative of initial value for standard deviation (not its log)."
-  rho?    

Should we only supply rho if it's outside the blue lines in the 'test' model? If so, how do we figure that out? In `?plot.acf`, it looks like these are a 95% confidence interval, but the help file doesn't say how the CI is calculated. Just says: "The confidence interval plotted in plot.acf is based on an uncorrelated series and should be treated with appropriate caution. Using ci.type = "ma" may be less potentially misleading."   

Can set `plot = FALSE` in the `acf()` call if we don't want to see it  

***  

# CBVGINUT {.tabset}  

NO23 - MDL increases; looks like the nutrient itself probably doesn't, so accounting for censoring is important.  

## Simple Regression  

```{r}
cbvgi_lm <- lm(lognut ~ dec_date, data = cbvgi)
summary(cbvgi_lm)
plot(residuals(cbvgi_lm))
acf(residuals(cbvgi_lm, type = "pearson"))
acf(residuals(cbvgi_lm, type = "pearson"))[1]
```


## Censored regression  

Censored regression correctly avoids identifying a positive trend in the nutrient.  

```{r}
cbvgi_cr <- with(cbvgi, cencorreg(nut, cens, dec_date,
                                  verbose = 0))
summary(cbvgi_cr)
```

```{r}
# # different package: survival
# library(survival)
# survreg(Surv(lognut, cens>0, type = "left") ~ dec_date, data = cbvgi)
```


## GAM w/censoring  

This slope should be the same as that from censored regression.  


## GAM w/seasonality only  

This slope will be most comparable to the simple regression model, and will be an inaccurate slope due to censoring. Seasonal term is significant. R^2 went up from 0.03 to 0.23. Even after accounting for seasonality, there's autocorrelation in the residuals.  

```{r}
cbvgi_gam_seas <- gam(lognut ~ dec_date + s(month, bs = "cc", k = 12),
                  data = cbvgi)
summary(cbvgi_gam_seas)
acf(residuals(cbvgi_gam_seas))
```


## GAM w/cens + seasonality  

Got a similar slope to the censored regression! -0.014 for the GAM; -0.008 for cenreg. Neither statistically significant. Can see from the GAM that seasonality is significant. Negative R^2 though?  

```{r}
# need a matrix with nutrient and censoring values
cbvgi$lognut_mat <- cbind(cbvgi$lognut, cbvgi$cens2)
cbvgi_gam_censseas <- gam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  data = cbvgi,
                  method = "REML")
summary(cbvgi_gam_censseas)
acf(residuals(cbvgi_gam_censseas))[1]
```



***  

# GNDHSNUT {.tabset}  

NH4F - seems to be decreasing, even with decreasing MDL.  

## Simple Regression  

```{r}
gndhs_lm <- lm(lognut ~ dec_date, data = gndhs)
summary(gndhs_lm)
plot(residuals(gndhs_lm))
acf(residuals(gndhs_lm, type = "pearson"))
acf(residuals(gndhs_lm, type = "pearson"))[1]
```

Not really any autocorrelation in the residuals.  

## Censored regression  

```{r}
gndhs_cr <- with(gndhs, cencorreg(nut, cens, dec_date,
                                  verbose = 0))
summary(gndhs_cr)
```


## GAM w/censoring  

This slope should be the same as that from censored regression.  


## GAM w/seasonality only  

This slope will be most comparable to the simple regression model. Slope is about the same as linear model. Seasonal term not significant. R^2 0.21 vs. 0.20 from linear model. Seasonal term doesn't impact the output in a negative way though; it's just not needed to explain this particular model.   

```{r}
gndhs_gam_seas <- gam(lognut ~ dec_date + s(month, bs = "cc", k = 12),
                  data = gndhs)
summary(gndhs_gam_seas)
```

```{r}
acf(residuals(gndhs_gam_seas))
```

Not seeing autocorrelation in the residuals.  

## GAM w/cens + seasonality  

Again, all similar.

```{r}
gndhs$lognut_mat <- cbind(gndhs$lognut, gndhs$cens2)
gndhs_gam_censseas <- gam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  data = gndhs,
                  method = "REML")
summary(gndhs_gam_censseas)
acf(residuals(gndhs_gam_censseas))[1]
```

 



***  

# GNDPCWQ {.tabset}  

spcond_median seems to be decreasing (?)  

## Simple Regression  

```{r}
gndpc_lm <- lm(param ~ dec_date, data = gndpc)
summary(gndpc_lm)
acf(residuals(gndpc_lm))[1]
```

Can see some seasonality in the residuals.  


## Simple GAM  

Should see same results as simple linear regression.  


## GAM w/seasonality  

Hopefully we get the same slope, but are accounting for seasonality.  

Seasonal term significant. Slope -0.477, st. error 0.080. R^2 0.50.  
From linear model, slope was -0.4892, st. error 0.1079, R^2 0.097. Seasonal GAM improved R^2 and standard error; didn't really change slope.  

Substantial autocorrelation (though it seems that accounting for seasonality took care of some of that).  

```{r}
gndpc_gam_seas <- gam(param ~ dec_date + s(month, bs = "cc", k = 12),
                  data = gndpc)
summary(gndpc_gam_seas)
acf(residuals(gndpc_gam_seas))[1]
pacf(residuals(gndpc_gam_seas))
```


## GAM w/AR  

Autocorrelation only. Should again get same slope; probably wider confidence intervals by accounting for autocorrelation.  



## GAM w/AR + seasonality  

The ultimate model.  

```{r}
gndpc_gam_ar <- gamm(param ~ dec_date + s(month, bs = "cc", k = 12),
                     data = gndpc,
                     correlation = corAR1(form = ~1|month),
                     method = "REML")
summary(gndpc_gam_ar$gam)
```




# GNDBCWQ {.tabset}  

cdepth_median seems to be increasing  

## Simple Regression  

```{r}
gndbc_lm <- lm(param ~ dec_date, data = gndbc)
summary(gndbc_lm)
acf(residuals(gndbc_lm))[1]
pacf(residuals(gndbc_lm))
```

## Simple GAM  

Should see same results as simple linear regression.  


## GAM w/seasonality  

Hopefully we get the same slope, but are accounting for seasonality. 

Seasonal term significant. Slope 0.032, st. error 0.002. R^2 0.76.  
From linear model, slope was 0.033, st. error 0.003, R^2 0.50. Seasonal GAM improved R^2 greatly and (slightly) standard error; didn't really change slope. 

Some autocorrelation in the residuals but not as much as I'd thought.  

```{r}
gndbc_gam_seas <- gam(param ~ dec_date + s(month, bs = "cc", k = 12),
                  data = gndbc)
summary(gndbc_gam_seas)
acf(residuals(gndbc_gam_seas))[1]
```

 
## GAM w/AR  

Autocorrelation only. Should again get same slope; probably wider confidence intervals by accounting for autocorrelation.  


## GAM w/AR + seasonality  

The ultimate model.  




# NIWOLWQ {.tabset}  

do-pct - doesn't seem to be changing (visually) 

## Simple Regression  

```{r}
niwol_lm <- lm(param ~ dec_date, data = niwol)
summary(niwol_lm)
plot(residuals(niwol_lm))
acf(residuals(niwol_lm, type = "pearson"))
acf(residuals(niwol_lm, type = "pearson"))[1]
```


## Simple GAM  

Should see same results as simple linear regression.  


## GAM w/seasonality  

Hopefully we get the same slope, but are accounting for seasonality.  

Seasonal term significant. Slope 0.0036, st. error 0.002, slope slightly significant now - p = 0.046. R^2 0.35.  
From linear model, slope was 0.004, st. error 0.002, R^2 0.017. Seasonal GAM greatly improved R^2. Didn't change standard error but did move slope to significant (p from linear model was 0.117), interestingly. Wonder if that will change when autocorrelation comes into play.   

```{r}
niwol_gam_seas <- gam(param ~ dec_date + s(month, bs = "cc", k = 12),
                  data = niwol)
summary(niwol_gam_seas)
acf(residuals(niwol_gam_seas))[1]
```



## GAM w/AR  

Autocorrelation only. Should again get same slope; probably wider confidence intervals by accounting for autocorrelation.  


## GAM w/AR + seasonality  

The ultimate model.  



***  
***  


# GAM with seasonality and censoring (nutrients only)  

mgcv::gam with cnorm family (censored data)  

https://stat.ethz.ch/R-manual/R-devel/library/mgcv/html/cnorm.html  



# Summary so far  

I trust the GAM so far. The linear term is similar as the linear model when there's little-to-no censoring. The linear term is similar to the censored regression slope when there *is* censoring (and it turns out to be necessary!); when there isn't censoring, it doesn't affect anything. Seasonality is accounted for if present, and reflected in the R^2 and presumably the confidence intervals. When it's not present, it doesn't hurt anything - slopes and R^2 come out similar to the GAM without a seasonal term.  


# GAM with seasonality and AR1 correlation structure  

How to look at the residual autocorrelation in the first place..... hmmmm.  

Some info in this Gavin Simpson blog post: https://fromthebottomoftheheap.net/2014/05/09/modelling-seasonal-data-with-gam/  

Though from my course I know that ACF and pACF can be wrong if you have missing data, which we most certainly do. Would be better to make a variogram; just need to find the code.  

But here's how to look at acf/pacf of gam output:  

```{r}
acf(cbmip_gam2$residuals)
acf(gndbc_gam1$residuals)
acf(niwol_gam1$residuals)
```


```{r}
library(gstat)
library(sp) # RETIRING OCTOBER 2023
library(ggplot2)
```

```{r}
niw2 <- na.omit(niwol)
#' We can also make a variogram to check for temporal dependency.
MyData2 <- data.frame(resids   = niwol_gam1$residuals, 
                      Time = niw2$dec_date, 
                      Ones = rep(1, nrow(niw2)))
coordinates(MyData2) <- c("Time", "Ones")
MyData2

V1 <- variogram(resids ~ Time,  
                MyData2, 
                # cutoff  = 159,
                cressie = TRUE)
V1

#' Plot the variogram
p <- ggplot()
p <- p + geom_point(data = V1,
                    aes(x = dist, 
                        y = gamma))
p <- p + xlab("Time") + ylab("Semi-variogram")
p <- p + theme(text = element_text(size = 15)) 
p <- p + theme(legend.position="none") 
p
```

```{r}
acf(niwol_gam1$residuals)
pacf(niwol_gam1$residuals) 
```

"The partial autocorrelation at lag k is the correlation that results after removing the effect of any correlations due to the terms at shorter lags." - p. 81, section 4.5.6, Introductory Time Series with R. Via: https://machinelearningmastery.com/gentle-introduction-autocorrelation-partial-autocorrelation/ 
 
That link says "A partial autocorrelation is a summary of the relationship between an observation in a time series with observations at prior time steps with the relationships of intervening observations removed."  

So if I'm interpreting things right: even though that NIW acf plot looks like there's correlation through the first 5 lags, the pacf plot shows that if we remove the correlation from the first lag, we'd have taken care of it.  

```{r}
gndhs2 <- na.omit(gndhs)
#' We can also make a variogram to check for temporal dependency.
MyData2 <- data.frame(resids   = gndhs_gam2$residuals, 
                      Time = gndhs2$dec_date, 
                      Ones = rep(1, nrow(gndhs2)))
coordinates(MyData2) <- c("Time", "Ones")
MyData2

V1 <- variogram(resids ~ Time,  
                MyData2, 
                # cutoff  = 159,
                cressie = TRUE)
V1

#' Plot the variogram
p <- ggplot()
p <- p + geom_point(data = V1,
                    aes(x = dist, 
                        y = gamma))
p <- p + xlab("Time") + ylab("Semi-variogram")
p <- p + theme(text = element_text(size = 15)) 
p <- p + theme(legend.position="none") 
p
```


```{r}
# E3 is pearson residuals from a fitted model using OU dependency
IC2$E3 <- resid(M3.ou, type = "pearson")

#' We can also make a variogram to check for temporal dependency.
MyData2 <- data.frame(E3   = IC2$E3, 
                      Year = IC2$Year - 1005, 
                      Ones = rep(1, nrow(IC2)))
coordinates(MyData2) <- c("Year", "Ones")
MyData2

V1 <- variogram(E3 ~ Year,  
                MyData2, 
                cutoff  = 159,
                cressie = TRUE)
V1

#' Plot the variogram
p <- ggplot()
p <- p + geom_point(data = V1,
                    aes(x = dist, 
                        y = gamma))
p <- p + xlab("Year") + ylab("Semi-variogram")
p <- p + theme(text = element_text(size = 15)) 
p <- p + theme(legend.position="none") 
p
```


Build up the seasonal GAM with gamm and play around with that.  

_gam1 are uncensored, with seasonal term  
_gam2 are censored, with seasonal term

```{r}
gndhs_gam3 <- gamm(lognut ~ dec_date + s(month, bs = "cc", k = 12),
                   data = gndhs)

summary(gndhs_gam3$gam)
# summary(gndhs_gam3$lme)
```

Results are essentially the same as from _gam1.  (very small differences in a couple spots)  


```{r}
cbvgi_gam3 <- gamm(lognut ~ dec_date + s(month, bs = "cc", k = 12),
                   data = cbvgi)

summary(cbvgi_gam3$gam)
# summary(gndhs_gam3$lme)
```

cbvgi is the one where it's the mdl making it look weird. Make sure censoring works in gamm like it does in gam.  

IT DOES NOT. 'gamm' can't work with family cnorm. Guess I need to figure it out in glmmTMB.  

```{r}
# cbvgi_gam4 <- gamm(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
#                    family = cnorm(),
#                    data = cbvgi,
#                    method = "REML")
# summary(cbvgi_gam4$gam)
```

Does bam work with cnorm?  

```{r}
cbvgi_gam4 <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                   family = cnorm(),
                   data = cbvgi,
                   method = "REML")
summary(cbvgi_gam4)
```

...yes it does...

Now how to figure out the autocorrelation?  

```{r}
cbvgi_gam4 <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  discrete = TRUE,
                  data = cbvgi,
                  method = "fREML")
summary(cbvgi_gam4)
```

Can I pull it from the residuals? Or is that circular?  

```{r}
rawresids <- cbvgi_gam4$residuals
attr(rawresids, "censor") <- NULL
acf(rawresids)
acf(rawresids)[1]
gamrho <- acf(rawresids)[1]$acf
```


```{r}
cbvgi_gam5 <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  discrete = TRUE,
                  rho = gamrho,  # from above
                  data = cbvgi,
                  method = "fREML")
summary(cbvgi_gam5)

rawresids <- cbvgi_gam5$residuals
attr(rawresids, "censor") <- NULL

ARresids <- mgcv:::AR.resid(rawresids, rho = cbvgi_gam5$AR1.rho)

plot(ARresids)
acf(ARresids)
```


```{r}
cbvgi_gam4b <- gam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  data = cbvgi,
                  method = "fREML")
summary(cbvgi_gam4b)

rawresids <- cbvgi_gam4b$residuals
attr(rawresids, "censor") <- NULL
acf(rawresids)
acf(rawresids)[1]
gamrho <- acf(rawresids)[1]$acf
```


```{r}
cbvgi_gam5b <- bam(lognut_mat ~ dec_date + s(month, bs = "cc", k = 12),
                  family = cnorm(),
                  discrete = TRUE,
                  rho = gamrho,  # from above
                  data = cbvgi,
                  method = "fREML")
summary(cbvgi_gam5b)

rawresids <- cbvgi_gam5b$residuals
attr(rawresids, "censor") <- NULL

ARresids <- mgcv:::AR.resid(rawresids, rho = cbvgi_gam5$AR1.rho)

plot(ARresids)
acf(ARresids)
```

standardized residuals are what you look at after including AR correlation in the model. Needed to pull an internal function from mgcv in order to calculate them due to the censoring.


uncensored bam, to figure out how to get at the standardized residuals:  
```{r}
testgam <- bam(lognut ~ dec_date + s(month, bs = "cc", k = 12),
               discrete = TRUE,
               rho = 0.26,
               data = cbvgi,
               method = "fREML")
summary(testgam)
plot(residuals(testgam))
plot(testgam$std.rsd)
acf(testgam$std.rsd)
```

Can I make my own standardized residuals? Problem is the residuals here have attributes for censoring, with -Inf involved.... but there are numeric values too, so maybe I can manually divide those by the standard deviation of the residuals?  

```{r}
rawresids <- cbvgi_gam5$residuals
attr(rawresids, "censor") <- NULL

ARresids <- mgcv:::AR.resid(rawresids, rho = cbvgi_gam5$AR1.rho)

plot(ARresids)
acf(ARresids)

resids2 <- scale(rawresids)

gam_stdres <- rawresids / sd(rawresids)

plot(gam_stdres)
acf(gam_stdres)
acf(resids2)

acf(gam_stdres)[1]

 
```


Nope, that doesn't come out the same as the standardized residuals pulled from `testgam$std.rsd`.  

```{r}
rawresids <- residuals(testgam)

gam_stdres <- rawresids / sd(rawresids)

plot(gam_stdres)
acf(gam_stdres)

acf(gam_stdres)[1]
```


# GAM with all of it  