---
title: "playing with time series"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      error = TRUE)

library(glmmTMB)
library(nlme)
library(mgcv)
```

I'm starting by following this tutorial on fitting autoregressive correlations using `glmmTMB`:  https://cran.r-project.org/web/packages/glmmTMB/vignettes/covstruct.html 

## simulate short time series  

Parameters:  

-  mean (mu) = 0  
-  process variance (sigma^2) = 1  
-  measurement variance (sigma^2 _0) = 1  
-  one-step correlation (phi) = 0.7  

```{r}
set.seed(80123)
n <- 25                                              ## Number of time points
x <- MASS::mvrnorm(mu = rep(0,n),
             Sigma = .7 ^ as.matrix(dist(1:n)) )    ## Simulate the process using the MASS package
y <- x + rnorm(n)                                   ## Add measurement noise

# create a factor of times in order to use glmmTMB; also need grouping level
times <- factor(1:n, levels=1:n)
head(levels(times))
group <- factor(rep(1,n))

dat0 <- data.frame(y, times, group)
```

Note - this looks stationary; i.e. there is no trend through time.  

## fit the model  

```{r}
glmmTMB(y ~ ar1(times + 0 | group), data=dat0)
```

In the output:  

-  mu is the intercept  
-  sigma^2_0 is the dispersion estimate
-  sigma is the standard deviation  
-  phi is the first off-diagonal of "Corr"  


## increase the number of groups  

```{r}
simGroup <- function(g, n=6, rho=0.7) {
    x <- MASS::mvrnorm(mu = rep(0,n),
             Sigma = rho ^ as.matrix(dist(1:n)) )   ## Simulate the process
    y <- x + rnorm(n)                               ## Add measurement noise
    times <- factor(1:n)
    group <- factor(rep(g,n))
    data.frame(y, times, group)
}
simGroup(1)
```

```{r}
# simulate 1000 groups
dat1 <- do.call("rbind", lapply(1:1000, simGroup) )
```

```{r}
(fit.ar1 <- glmmTMB(y ~ ar1(times + 0 | group), data=dat1))
```

Looks much better.  

The rest of the tutorial really doesn't give any information on working with trends though. So for the rest of this doc, I'm striking out on my own.  

## insert a trend  



```{r}
set.seed(80123)
n <- 100                                              ## Number of time points

x1 <- seq(1:n)
mus <- x1 * 1.2 # making up a trend???

x <- MASS::mvrnorm(mu = mus,
             Sigma = .7 ^ as.matrix(dist(1:n)) )    ## Simulate the process using the MASS package
y <- x + rnorm(n, 0, n/5)                                   ## Add measurement noise

# create a factor of times in order to use glmmTMB; also need grouping level
times <- factor(1:n, levels=1:n)
head(levels(times))
group <- factor(rep(1,n))

dat0 <- data.frame(y, x1, times, group)
```

```{r}
plot(y ~ x1)
```


```{r}
glmmTMB(y ~ ar1(times + 0 | group), data=dat0)

(gls1 <- gls(y ~ x1, data = dat0,
    correlation = corAR1()))

# vs. regular linear model
(lm1 <- lm(y ~ x1, data = dat0))

confint(gls1)
confint(lm1)
```


# From the ground up  

Okay, let's say I want a monthly time series of chlorophyll data that's increasing by 1 ug/L/yr for 10 years = 0.083 ug/L/month.  

```{r}
library(tidyverse)
```


```{r}
dat <- data.frame(index = seq(1:120),
                  year = rep(2000:2009, each = 12),
                  month = rep(1:12, times = 10))

x1 <- 5 + 0.083*dat$index  # simulated mean 
plot(x1)

# seasonal effects
seas <- data.frame(month = 1:12,
                   effect = c(-1, -0.5, -0.2,
                              0.2, 0.5, 0.8,
                              0.8, 0.5, 0.2,
                              -0.2, -0.5, -1))

x2 <- x1 + rep(seas$effect, times = 10)
plot(x2)

# noise
x3 <- x2 + rnorm(length(x2), 0, 0.5)
plot(x3)
plot(x3, type = "l")

dat <- dat %>% 
  mutate(simchl = x3,
         date = lubridate::ymd(paste(year, month, "01")),
         decDate = lubridate::decimal_date(date))

ggplot(dat, aes(x = decDate, y = simchl)) +
  geom_point() +
  geom_line(alpha = 0.5) +
  theme_bw()
```


The true slope of the line is 1 per year. Seasonal effects were specified. Autocorrelation was **not** built in.  

```{r}
# no seasonality
(lm_basic <- lm(simchl ~ decDate, data = dat))

# old-school seasonality (sin and cos terms)
(lm_seasonal <- lm(simchl ~ decDate + sin(2*pi*decDate) + cos(2*pi*decDate), data = dat))

# seasonality with gam
(gam1 <- gam(simchl ~ decDate + s(month, bs = "cc"),
             data = dat))
```


## compare the models  

```{r}
AIC(lm_basic, lm_seasonal, gam1) %>% 
  arrange(AIC) %>% 
  knitr::kable()
```

Using sin and cos terms in a regular linear model works pretty well here (on this very clumsily simulated dataset). GAM is better according to AIC, but only slightly - difference is less than 2, indicating both models perform similarly well.  

```{r}
lm1 <- broom::tidy(lm_basic) %>% 
  mutate(model = "linear-basic",
         rsquared = summary(lm_basic)$r.squared)
lm2 <- broom::tidy(lm_seasonal) %>% 
  mutate(model = "linear + season",
         rsquared = summary(lm_seasonal)$r.squared)
gam2 <- data.frame(summary(gam1)$p.table) %>% 
  rownames_to_column(var = "term") %>% 
  mutate(model = "gam",
         rsquared = summary(gam1)$r.sq)
names(gam2) <- c("term", "estimate", "std.error", "statistic", "p.value", "model", "rsquared")

bind_rows(lm1, lm2, gam2) %>% 
  relocate(model) %>% 
  filter(term == "decDate") %>% 
  knitr::kable()
```


